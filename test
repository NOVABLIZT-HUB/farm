-- // 1. FPS CAP //
if setfpscap then setfpscap(3) end

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")

local LocalPlayer = Players.LocalPlayer
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart", 10)

-- // 2. UI STATUS //
local ScreenGui, StatusLabel
pcall(function()
    if CoreGui:FindFirstChild("HastyUI") then CoreGui.HastyUI:Destroy() end
    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "HastyUI"
    local parent = CoreGui
    if not pcall(function() parent = CoreGui end) then parent = LocalPlayer:WaitForChild("PlayerGui") end
    ScreenGui.Parent = parent

    StatusLabel = Instance.new("TextLabel")
    StatusLabel.Parent = ScreenGui
    StatusLabel.Size = UDim2.new(0, 300, 0, 30)
    StatusLabel.Position = UDim2.new(0.5, -150, 0, 10)
    StatusLabel.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    StatusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
    StatusLabel.TextSize = 18
    StatusLabel.Text = "Status: Booting..."
end)

local function SetStatus(text)
    if StatusLabel then StatusLabel.Text = text end
end

-- // 3. SETUP //
local CoinsFolder = Workspace:FindFirstChild("CoinsFolder") or Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

local WalkingPlatform = Workspace:FindFirstChild("WalkingPlatform") or Instance.new("Part")
WalkingPlatform.Name = "WalkingPlatform"
WalkingPlatform.Size = Vector3.new(5, 1, 5)
WalkingPlatform.Anchored = true
WalkingPlatform.Transparency = 1 
WalkingPlatform.CanCollide = true
WalkingPlatform.Parent = Workspace

local visited = {}
local currentPlatformY = 148
local FailCount = 0 

-- // 4. FAILSAFE HOP //
local function ServerHop()
    SetStatus("Fails > 20. Hopping...")
    local PlaceId = game.PlaceId
    local Api = "https://games.roblox.com/v1/games/"
    local _servers = Api..PlaceId.."/servers/Public?sortOrder=Desc&limit=100"
    
    local function ListServers(cursor)
        local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
        return HttpService:JSONDecode(Raw)
    end

    local Server, Next
    repeat
        local Servers = ListServers(Next)
        Server = Servers.data[math.random(1, #Servers.data)]
        Next = Servers.nextPageCursor
    until Server and Server.playing < Server.maxPlayers and Server.id ~= game.JobId

    TeleportService:TeleportToPlaceInstance(PlaceId, Server.id, LocalPlayer)
end

-- // 5. MAP PROCESSOR (The Fix) //
local function ProcessMap(child)
    if not child:IsA("Model") then return end
    
    task.spawn(function()
        local container = child:FindFirstChild("CoinContainer")
        local t = 0
        -- Wait for container
        while not container and child.Parent do
            task.wait(1)
            t = t + 1
            container = child:FindFirstChild("CoinContainer")
            if t > 30 then return end
        end
        
        if not container then return end
        SetStatus("Map Found: " .. child.Name)

        local function moveCoin(coin)
            if not coin or coin:GetAttribute("Collected") then return end
            [cite_start]task.wait(0.6) -- Delay [cite: 24]
            
            -- FIX: We trust ANYTHING in the container that is a Part
            if coin:IsA("BasePart") then
                coin.Parent = CoinsFolder
                
                -- VISUAL DEBUG: Green = Script sees it
                coin.Color = Color3.fromRGB(0, 255, 0)
                coin.Transparency = 0.5 
                
                coin:SetAttribute("Collected", false)
            end
        end

        for _, coin in ipairs(container:GetChildren()) do
            moveCoin(coin)
        end
        container.ChildAdded:Connect(moveCoin)
    end)
end

for _, child in ipairs(Workspace:GetChildren()) do ProcessMap(child) end
Workspace.ChildAdded:Connect(ProcessMap)

-- // 6. SEARCH LOGIC //
local function FindBestCoin(radius, hrp)
    local candidates = {}
    local coins = CoinsFolder:GetChildren()
    
    for _, coin in ipairs(coins) do
        -- Check strict TouchInterest to ensure collectability
        if coin:IsA("BasePart") and not visited[coin] and coin:FindFirstChild("TouchInterest") then
            if (coin.Position - hrp.Position).Magnitude <= radius then
                table.insert(candidates, coin)
            end
        end
    end
    
    if #candidates == 0 then return nil end
    return candidates[math.random(1, #candidates)]
end

[cite_start]-- // 7. WATERFALL WAIT [cite: 37] //
local function RandomWaterfallWait(hrp)
    SetStatus("Waiting (Waterfall)...")
    
    task.wait(0.5)
    local c1 = FindBestCoin(50, hrp)
    if c1 then return c1 end

    task.wait(0.3)
    local c2 = FindBestCoin(50, hrp)
    if c2 then return c2 end
    
    task.wait(0.4)
    local c3 = FindBestCoin(50, hrp)
    if c3 then return c3 end
    
    return nil
end

-- // 8. PLATFORM LOOP //
RunService.Heartbeat:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPos = LocalPlayer.Character.HumanoidRootPart.Position
        WalkingPlatform.CFrame = CFrame.new(rootPos.X, currentPlatformY, rootPos.Z)
    end
end)

-- // 9. TELEPORT //
local function TeleportToCoin(coin, hrp)
    if not hrp or not coin or not coin.Parent then return false end
    if not coin:FindFirstChild("TouchInterest") then return false end

    SetStatus("Teleporting...")
    
    local pos = coin.Position
    currentPlatformY = pos.Y - 2
    WalkingPlatform.CFrame = CFrame.new(pos.X, currentPlatformY, pos.Z)

    [cite_start]-- LookAt Logic [cite: 26]
    local directionVector = (pos - hrp.Position)
    if directionVector.Magnitude < 0.1 then
        hrp.CFrame = CFrame.new(pos)
    else
        local lookAtPos = pos + (directionVector.Unit * 5)
        hrp.CFrame = CFrame.new(pos, lookAtPos)
    end
    
    local startTime = tick()
    local maxWaitTime = 1.0 
    
    repeat
        if coin and coin.Parent and coin:FindFirstChild("TouchInterest") then
            firetouchinterest(coin, hrp, 0)
            task.wait(0.15)
            firetouchinterest(coin, hrp, 1)
            task.wait(0.15)
        else
            [cite_start]task.wait(0.3) -- [cite: 30]
        end
    until (tick() - startTime) > maxWaitTime
    
    return true
end

[cite_start]-- // 10. RESET LOGIC [cite: 68] //
local function CheckAndResetIfFull(hum)
    local s, r = pcall(function()
        return ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
    end)
    if s and r and r[LocalPlayer.Name] and r[LocalPlayer.Name].Coins >= 50 then
        SetStatus("Full (50). Resetting...")
        hum.Health = 0
        task.wait(5)
        return true
    end
    return false
end

-- // 11. MAIN LOOP //
task.spawn(function()
    while task.wait(0.5) do
        [cite_start]-- Fail Check [cite: 83]
        if FailCount >= 20 then
            ServerHop()
            task.wait(10)
        end

        -- Round Check
        if not RoundTimerPart or RoundTimerPart:GetAttribute("Time") == -1 then
            if #visited > 0 then
                SetStatus("Round Ended. Clearing.")
                table.clear(visited)
                CoinsFolder:ClearAllChildren()
                FailCount = 0
            else
                SetStatus("Waiting for Round...")
            end
            continue
        end

        -- Player Check
        local Char = LocalPlayer.Character
        local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
        local Hum = Char and Char:FindFirstChild("Humanoid")
        
        if not HRP or not Hum or Hum.Health <= 0 then
            SetStatus("Waiting for Spawn...")
            continue
        end

        -- 50/50 Check
        if CheckAndResetIfFull(Hum) then continue end

        -- Coin Logic
        local coin = FindBestCoin(2000, HRP)
        if coin then
            local success = TeleportToCoin(coin, HRP)
            if success then
                visited[coin] = true
                FailCount = 0 
                
                [cite_start]-- Chain Loop [cite: 74]
                for i = 1, 5 do
                    if CheckAndResetIfFull(Hum) then break end
                    
                    local nextCoin = RandomWaterfallWait(HRP)
                    if nextCoin then
                        local chainSuccess = TeleportToCoin(nextCoin, HRP)
                        if chainSuccess then
                            visited[nextCoin] = true
                            FailCount = 0
                        else
                            FailCount = FailCount + 1
                            break
                        end
                    else
                        break 
                    end
                end
            else
                FailCount = FailCount + 1
                SetStatus("TP Failed ("..FailCount..")")
            end
        else
            SetStatus("Searching... (Folder: "..#CoinsFolder:GetChildren()..")")
        end
    end
end)
