if _G.Start then
	print("Script is already running.")
	return
end

_G.Start = true
-- getgenv().Config = {}

local Default_Config = {
	--["Script_Key"] = "",
	["CPU Saver"] = true,

	["Auto Open"] = {
		["Enabled"] = false,
		["Crate"] = "",
	},

	["Webhook"] = {
		["URL"] = "",
		["UserID"] = "",
		["Only Good Webhook"] = false,
	},

	["Other"] = {
		["Auto Prestige"] = true,
		-- ["Auto Restart on Update"] = false,
		-- ["Auto Craft"] = false,
	},

	
	["Event"] = {
		["Auto Do Battle Pass"] = true,
	},

	["Misc"] = {
		-- ["FARM_MURDERER_SHERIF_WINS"] = true,
		-- ["STOP_MURDERER_AFTER_KILLS"] = 20,
		-- ["FPS"] = 3,
		["HopServer"] = false,
		["MaxFails"] = 10
		-- ƒê√£ x√≥a AutoShutdown
	}
}

local function mergeConfig(default, user)
	if type(default) ~= "table" then
		return user
	end
	user = user or {}
	for k, v in pairs(default) do
		if type(v) == "table" then
			user[k] = mergeConfig(v, user[k])
		elseif user[k] == nil then
			user[k] = v
		end
	end
	return user
end

local cfg = (getgenv and getgenv().Config) or _G.Config or {}
cfg = mergeConfig(Default_Config, cfg)

local Version = "v2.4.5 Halloween Faster idk" .. "\n"
local NewestVersion
local usernameRevealed = false
local ChromaAnimation = false
local last_print = ""

local SessionCrates = 0
local TotalStagesBought = 0
local TotalWeapons = 0
local TotalGodlies, TotalChromas = 0, 0

local TotalRoundswithout30coinsplus = 0

local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Terrain = Workspace:WaitForChild("Terrain")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local PhysicsService = game:GetService("PhysicsService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

local Api = "https://games.roblox.com/v1/games/"
local PlaceId = game.PlaceId
local _servers = Api .. PlaceId .. "/servers/Public?sortOrder=Asc&limit=100&excludeFullGames=true"

local headers = {
	["Content-Type"] = "application/json",
	["Cookie"] = ".ROBLOSECURITY=_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_CAEaAhAB.83AC569F43419E1C1D7906A03D3CFB5F86D9345E5EB159BE89FEB143297BEBCDAAD6EF9709ADEDB1F7408D13FC48AAC7F38A3A78D8B4EF507DA98433311161481B56EAE24EDD3F64EEE4E31AFB04A5282E70A5CDF78BDD8C29A30796FE06DFCA038B7ACA54E09D0A398D4A7AF9D0805F7AC44B3B6C0504202BC8A741E9A7D388B8B75F235E3588ED922D7425764D3E6AD996F2C9D9047B024550B1DF3BC322184823784E14B76FEFCD6A18C05DEA35CB372A6BE2F0A21A6BB6F6CE4ED370CA775CED029A2B608B4392B26DB996C6E83D8636CE06466EFA371D1E4E7C8F4AE2EDD8FD2D24B11316858DFB789F3CDFA7ADEB9976368E73031CDCEF395C034E8A5348CB26AC90EFDFD60064255486EE0D26842F937271AD65FC867031F7EF30A955EACAD07785E1272E6A7D579FCD94F2F3FEBD9B0425AF9ACBD85E786C4404DCDD77005157DF7F150C6B7A71185E01B0326065B4DCDAF8D375C1586CD8C995597614C09ACF28BD8B80B450FA2656E1152C4FD99758CFA45CEA0E856D8AC589E0FC8F77352DFF67FC4AAF1F859614E5FB48FB13C8E33CCF5CAD85D49DC36EDFEE79501DE77329CB9155B5A27BF4C333CBE413BE3E1BC0D0C8C97CC3C2B68EB59A4F7CE7BA1CED3B179FC2EC844E0F03337094DDC7B80B7996E398E643952BCC1BBE17A2136F7EBDF680D157D647E96F68B0F813B5BB293F60D1C0281B9F60C15F866B777E250BA4AB621711845799B773A8921C13F542CAAC45E5EC427AF5E91CC791ECE23D7205603F480F40059D7612C25F3C387966A194CC3D8AF2FCA0D6DADD6E2E5B4C234D65AF76DCC66F5AB129F2F2C92390005AF4B41E4F717F2FC141BECCAECD90F630CD2B46BACD35BADD72635CE50D9C56524F3F080E7C91169CCAD27B9F30BB3B5A961DF4928DA852FD8F56533ECE9936306CC543F34BCB6B38499AD72F02B57BA1BCF31773A696115EF6C7669615E17FF62DBCA96A6A4F20FA5E2C81DCFE445F4CF5A58A8841ADA7BB000E48570BEA4D0ED2736C0ACDFD1291FC25308E7107359C229DA706F67ADBC45C6F595CB55BCE7BA0FB83A16517FC88DDCBFCC8AC667BF9EDF11EB72F652177BC5CE26C46083F0CE4A4F391C00F0FD81E371E4560BC8769E5B3EEBBCCD06A7341AD0AEAD712597DC55774C433FB523D2FF8553EB9F4347F411BBE6090B9096D9844C20638D02B476BF9CBC5B18F692A1D0E199B04394373D6FA7A75F76834C43676EADE134DF9A0DFEE617B449861DEF793CC2178CF" -- dein Roblox Cookie hier einf√É¬ºgen
}

local map = nil
local AllCoins = {}
-- local knife = nil
-- local gun = nil
local GoodPeople = {}
local visited = {}

repeat
	task.wait()
until game:IsLoaded()
	and game.Players.LocalPlayer.Character
	and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	and Workspace:FindFirstChild("Lobby")

if cfg["CPU Saver"] then
	task.spawn(function()
		while task.wait(5) do
			-- setfpscap(cfg["Misc"]["FPS"])
		end
	end)
end

-- task.spawn(function()
-- 	if cfg["Other"]["Auto Restart on Update"] then
-- 		NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
-- 		while task.wait(600) do
-- 			NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
-- 			if NewestVersion ~= Version then
-- 				
-- 			end
-- 		end
-- 	end
-- end)


-- Clean up unnecessary Workspace objects
Workspace:WaitForChild("Lobby"):Destroy()
Workspace:WaitForChild("WeaponDisplays"):Destroy()
Workspace:WaitForChild("PetContainer"):Destroy()
Workspace:WaitForChild("EffectLoader"):Destroy()
Workspace:WaitForChild("ServerStatus"):Destroy()
Workspace:WaitForChild("GameSettings"):Destroy()

-- Set up player and round references
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
local Humanoid = character:WaitForChild("Humanoid")
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local Database = ReplicatedStorage:WaitForChild("Database")
local Sync = Database:WaitForChild("Sync")


task.spawn(function()
	local GC = getconnections or get_signal_cons

	if GC then
		for i, v in pairs(GC(player.Idled)) do
			if v.Disable then
				v:Disable()
			elseif v.Disconnect then
				v:Disconnect()
			end
		end
	end

	player.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)

end)


-- Set up Modules
local Modules = ReplicatedStorage:WaitForChild("Modules")
local SharedServices = ReplicatedStorage:WaitForChild("SharedServices")

local LevelModule = require(Modules.LevelModule)
local ProfileData = require(Modules.ProfileData)
local EventInfoService = require(SharedServices.EventInfoService)


-- Populate Godly and Chroma item lists
local GodlyList = {}
local ChromaList = {}

for _, BoxData in pairs(require(Sync.MysteryBox)) do
	if not BoxData.Godly then
		for _, Item in pairs(BoxData.GodlyTable) do
			table.insert(GodlyList, Item)
		end
	elseif type(BoxData.Godly) == "string" then
		table.insert(GodlyList, BoxData.Godly)
	end
	if BoxData.ChromaTable then
		for _, Item in pairs(BoxData.ChromaTable) do
			table.insert(ChromaList, Item)
		end
	end
end

local RoundData = Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
local Data = require(Modules.ProfileData)
local LastRoundData = nil

local StartedCoins = 0
local Event = nil


StartedCoins = Data.Materials.Owned[EventInfoService.GetEventCurrency()] or 0
Event = EventInfoService:GetCurrentEvent()

local PlayerLevel, NextLevelXP = LevelModule.GetLevel(Data.NewXP)
local OwnedWeapons = Data["Weapons"]["Owned"]
local totalCoins = StartedCoins

local SafetyPart = Instance.new("Part")
SafetyPart.Parent = Workspace
SafetyPart.Size = Vector3.new(100, 1, 100)
SafetyPart.Position = Vector3.new(0, 0, 0)
SafetyPart.Anchored = true
SafetyPart.Name = "SafetyPart"
SafetyPart.Transparency = 1

local CoinsFolder = Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

-- Create LobbyPlatform for lobby positioning
local LobbyPlatform = Instance.new("Part")
LobbyPlatform.Parent = Workspace
LobbyPlatform.Size = Vector3.new(100, 1, 100)
LobbyPlatform.Position = Vector3.new(-100, 136, 30)
LobbyPlatform.Anchored = true
LobbyPlatform.Name = "LobbyPlatform"
LobbyPlatform.Transparency = 1

-- Position the player at the safety platform
HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)

--UI
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local RoleDisplay = Instance.new("TextLabel")
local PrestigeLabel = Instance.new("TextLabel")
local LevelLabel = Instance.new("TextLabel")
local Title = Instance.new("TextLabel")
local TimerLabel = Instance.new("TextLabel")
local RevealUsernameButton = Instance.new("TextButton")
local Logo = Instance.new("ImageButton")
local StatusText = Instance.new("TextLabel")
local TotalGodlyLabel = Instance.new("TextLabel")
local TotalWeaponsLabel = Instance.new("TextLabel")
local TotalChromasLabel = Instance.new("TextLabel")
local CurrentCoinsLabel = Instance.new("TextLabel")
local RoundCoinsLabel = Instance.new("TextLabel")
local SessionCoinsLabel = Instance.new("TextLabel")
local VersionLabel = Instance.new("TextLabel")

ScreenGui.Parent = CoreGui
ScreenGui.IgnoreGuiInset = true

MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.new(0, 0, 0)
MainFrame.Size = UDim2.new(1, 0, 1, 0)

if cfg["CPU Saver"] then
	MainFrame.BackgroundTransparency = 0
else
	MainFrame.BackgroundTransparency = 0.5
end

RoleDisplay.Parent = MainFrame
RoleDisplay.BackgroundTransparency = 1.000
RoleDisplay.Position = UDim2.new(0.39165011, 0, 0.172029704, 0)
RoleDisplay.Size = UDim2.new(0.200000018, 0, 0.100000001, 0)
RoleDisplay.Font = Enum.Font.FredokaOne
RoleDisplay.Text = "Role: Innocent (Placeholder)"
RoleDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
RoleDisplay.TextScaled = true

PrestigeLabel.Parent = MainFrame
PrestigeLabel.BackgroundTransparency = 1.000
PrestigeLabel.Position = UDim2.new(0.390987396, 0, 0.376237631, 0)
PrestigeLabel.Size = UDim2.new(0.200000018, 0, 0.0960000008, 0)
PrestigeLabel.Font = Enum.Font.FredokaOne
PrestigeLabel.Text = "Prestige: 0"
PrestigeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PrestigeLabel.TextScaled = true

LevelLabel.Parent = MainFrame
LevelLabel.BackgroundTransparency = 1.000
LevelLabel.Position = UDim2.new(0.39165011, 0, 0.27722773, 0)
LevelLabel.Size = UDim2.new(0.25, 0, 0.0962871313, 0)
LevelLabel.Font = Enum.Font.FredokaOne
LevelLabel.Text = "Level: 0"
LevelLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
LevelLabel.TextScaled = true

Title.Parent = MainFrame
Title.BackgroundTransparency = 1.000
Title.Position = UDim2.new(0.274353892, 0, 0.0284653474, 0)
Title.Size = UDim2.new(0.450629562, 0, 0.128712878, 0)
Title.Font = Enum.Font.FredokaOne
Title.Text = "Hasty MM2 Coin Farmer"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true

TimerLabel.Parent = MainFrame
TimerLabel.BackgroundTransparency = 1.000
TimerLabel.Position = UDim2.new(0.25, 0, 0.8, 0)
TimerLabel.Size = UDim2.new(0.6, 0, 0.15, 0)
TimerLabel.Font = Enum.Font.FredokaOne
TimerLabel.Text = "Time Farming: 00:00:00"
TimerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TimerLabel.TextScaled = true

RevealUsernameButton.Parent = MainFrame
RevealUsernameButton.BackgroundTransparency = 1.000
RevealUsernameButton.Position = UDim2.new(0.258805811, 0, 0.756079197, 0)
RevealUsernameButton.Size = UDim2.new(0.465871423, 0, 0.074257426, 0)
RevealUsernameButton.Font = Enum.Font.FredokaOne
RevealUsernameButton.Text = "Reveal Username"
RevealUsernameButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RevealUsernameButton.TextScaled = true

Logo.Parent = MainFrame
Logo.Size = UDim2.new(0, 100, 0, 100)
Logo.Image = "rbxassetid://72063995210355"

StatusText.Parent = MainFrame
StatusText.BackgroundTransparency = 1.000
StatusText.Position = UDim2.new(0.259112, 0, 0.560643554, 0)
StatusText.Size = UDim2.new(0.465871423, 0, 0.126237631, 0)
StatusText.Font = Enum.Font.FredokaOne
StatusText.Text = "Status: Loading"
StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusText.TextScaled = true

TotalGodlyLabel.Parent = MainFrame
TotalGodlyLabel.BackgroundTransparency = 1.000
TotalGodlyLabel.Position = UDim2.new(0.0240000002, 100, 0.27722773, 0)
TotalGodlyLabel.Size = UDim2.new(0.200000033, 0, 0.0962871313, 0)
TotalGodlyLabel.Font = Enum.Font.FredokaOne
TotalGodlyLabel.Text = "Godly: 0"
TotalGodlyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalGodlyLabel.TextScaled = true

TotalWeaponsLabel.Parent = MainFrame
TotalWeaponsLabel.BackgroundTransparency = 1.000
TotalWeaponsLabel.Position = UDim2.new(0.0240000002, 100, 0.376237631, 0)
TotalWeaponsLabel.Size = UDim2.new(0.200000018, 0, 0.0960000008, 0)
TotalWeaponsLabel.Font = Enum.Font.FredokaOne
TotalWeaponsLabel.Text = "Total: 0"
TotalWeaponsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalWeaponsLabel.TextScaled = true

TotalChromasLabel.Parent = MainFrame
TotalChromasLabel.BackgroundTransparency = 1.000
TotalChromasLabel.Position = UDim2.new(0.0240000002, 100, 0.172029704, 0)
TotalChromasLabel.Size = UDim2.new(0.200000018, 0, 0.100000001, 0)
TotalChromasLabel.Font = Enum.Font.FredokaOne
TotalChromasLabel.Text = "Chromas: 0"
TotalChromasLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalChromasLabel.TextScaled = true

CurrentCoinsLabel.Parent = MainFrame
CurrentCoinsLabel.BackgroundTransparency = 1.000
CurrentCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.16707921, 0)
CurrentCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
CurrentCoinsLabel.Font = Enum.Font.FredokaOne
CurrentCoinsLabel.Text = "Current Coins: 0"
CurrentCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CurrentCoinsLabel.TextScaled = true

RoundCoinsLabel.Parent = MainFrame
RoundCoinsLabel.BackgroundTransparency = 1.000
RoundCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.375, 0)
RoundCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
RoundCoinsLabel.Font = Enum.Font.FredokaOne
RoundCoinsLabel.Text = "Round Coins: 0"
RoundCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
RoundCoinsLabel.TextScaled = true

SessionCoinsLabel.Parent = MainFrame
SessionCoinsLabel.BackgroundTransparency = 1.000
SessionCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.272277236, 0)
SessionCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
SessionCoinsLabel.Font = Enum.Font.FredokaOne
SessionCoinsLabel.Text = "Session Coins: 0"
SessionCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
SessionCoinsLabel.TextScaled = true

VersionLabel.Parent = MainFrame
VersionLabel.BackgroundTransparency = 1.0
VersionLabel.Position = UDim2.new(0.85, 0, 0.95, 0)
VersionLabel.Size = UDim2.new(0.15, 0, 0.05, 0)
VersionLabel.Font = Enum.Font.SourceSansBold
VersionLabel.Text = Version
VersionLabel.TextColor3 = Color3.new(1, 1, 1)
VersionLabel.TextScaled = true

RevealUsernameButton.MouseButton1Click:Connect(function()
	if not usernameRevealed then
		RevealUsernameButton.Text = "Username: " .. player.Name
		usernameRevealed = true
	else
		RevealUsernameButton.Text = "Reveal Username"
		usernameRevealed = false
	end
end)

-- ƒê√É X√ìA TASK.SPAWN C·ª¶A AUTOSHUTDOWN

task.spawn(function()
	while task.wait() do
		for _, coin in ipairs(CoinsFolder:GetChildren()) do
			if coin:FindFirstChild("TouchInterest") then
				task.spawn(function()
					firetouchinterest(coin, HumanoidRootPart, 0)
					task.wait()
					firetouchinterest(coin, HumanoidRootPart, 1)
				end)
			end
		end
	end
end)

local function ClearMap()
	if map then
		for _, child in ipairs(map:GetChildren()) do
			if child:IsA("Model") and child.Name ~= "CoinContainer" then
				child:Destroy()
				print("Destroyed map object: " .. child.Name)
			end
		end
	end
end

-- This is where FindNearCoins used to be. It's replaced by the logic in Start_Farm.

local function ProccessMap(child)
	if not child:GetAttribute("MapID") then return end

	repeat task.wait() until child:FindFirstChild("CoinContainer")

	print("Map found: " .. child.Name)

	local conn = nil
	AllCoins = {}
	conn = child.CoinContainer.ChildAdded:Connect(function(coin)
		if not coin or coin:GetAttribute("Collected") then return end

		table.insert(AllCoins, coin)

		task.wait(0.5)
		if coin:FindFirstChild("CoinVisual") and cfg["CPU Saver"] then
			coin.CoinVisual:Destroy()
		end

		coin.Parent = CoinsFolder
		coin:SetAttribute("Collected", false)
		coin.Transparency = 1
	end)

	while child.CoinContainer and child.CoinContainer.Parent == child do
		task.wait()
	end

	if conn then conn:Disconnect() end
end


local function calculateTime(distance)
	local t = 0.024 * distance + 0.2
	if t < 2.5 then
		t = 2
	end
	return t
end

task.spawn(function()
	for _, child in ipairs(Workspace:GetChildren()) do
		ProccessMap(child)
	end
end)



local MapMove_handler = Workspace.ChildAdded:Connect(function(child)
	ProccessMap(child)
end)

local lastPing = tick()

-- local chainCount = 1

--// Teleport to Coin (modified to have no walking)
local function TeleportToCoin(coin)
	if not HumanoidRootPart or not Humanoid or not coin or not coin.Position then
		return
	end

	local pos = coin.Position
	local currentPos = HumanoidRootPart.Position
	local direction = (pos - currentPos)

	-- Ki·ªÉm tra xem kho·∫£ng c√°ch c√≥ qu√° nh·ªè kh√¥ng (ƒë·ªÉ tr√°nh l·ªói .Unit tr√™n vector 0)
	if direction.Magnitude < 0.1 then
		HumanoidRootPart.CFrame = CFrame.new(pos)
	else
		HumanoidRootPart.CFrame = CFrame.new(pos, pos + direction)
	end

	-- üîπ Fast touch cycle
	task.spawn(function()
		task.wait()
		if coin:FindFirstChild("TouchInterest") then
			repeat
				firetouchinterest(coin, HumanoidRootPart, 0)
				task.wait()
				firetouchinterest(coin, HumanoidRootPart, 1)
				task.wait()
			until not coin:FindFirstChild("TouchInterest")
		end
	end)
    
    -- üîπ No random walking movement
	-- task.delay(0.3, function()
	-- 	if Humanoid and HumanoidRootPart then
	-- 		local offset = Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
	-- 		local walkPos = HumanoidRootPart.Position + offset
	-- 		Humanoid:MoveTo(walkPos)
	-- 		task.wait(math.random(1, 2)) -- 1‚Äì2 s random walk
	-- 		Humanoid:MoveTo(HumanoidRootPart.Position)
	-- 	end
	-- end)

	task.wait(0.1)
end

-- T√åM COIN T·ªêT NH·∫§T (LOGIC M·ªöI)
local function FindBestCoin(searchRadius, neighborRadius)
	if not HumanoidRootPart then return nil end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then return nil end

	-- 1. L·ªçc c√°c coin trong b√°n k√≠nh t√¨m ki·∫øm
	local coinsInRadius = {}
	for _, coin in ipairs(allValidCoins) do
		local dist = (coin.Position - HumanoidRootPart.Position).Magnitude
		if dist <= searchRadius then
			table.insert(coinsInRadius, coin)
		end
	end

	if #coinsInRadius == 0 then
		return nil
	end

	-- 2. T√¨m coin c√≥ nhi·ªÅu "h√†ng x√≥m" nh·∫•t
	local bestCoin = nil
	local maxNeighbors = -1

	for _, coin in ipairs(coinsInRadius) do
		local neighborCount = 0
		for _, otherCoin in ipairs(allValidCoins) do
			if coin ~= otherCoin then
				local dist = (coin.Position - otherCoin.Position).Magnitude
				if dist <= neighborRadius then
					neighborCount = neighborCount + 1
				end
			end
		end

		if neighborCount > maxNeighbors then
			maxNeighbors = neighborCount
			bestCoin = coin
		end
	end

	return bestCoin
end


local function FindCoin(isFirst)
	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] then
		return "Dead"
	end


	-- if RoundData
	-- 	and RoundData[player.Name]
	-- 	and RoundData[player.Name]["Coins"] == 40
	-- 	and cfg["Misc"]["FARM_MURDERER_SHERIF_WINS"]
	-- 	and RoundData[player.Name]["Role"]
	-- 	and (RoundData[player.Name]["Role"] == "Murderer" or RoundData[player.Name]["Role"] == "123123")
	-- then
	-- 	return "WinRound1"
	-- end


	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] == 40 then
		return "Full"
	end

	if not HumanoidRootPart or not AllCoins then
		return nil
	end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then
		debug_print("FindCoin: Found 0 total valid coins on map.")
		return "NoCoins"
	end
	
	if isFirst then
		debug_print("FindCoin (Global): Picking a random coin from " .. #allValidCoins .. " total.")
		local bestCoin = allValidCoins[math.random(1, #allValidCoins)]
		return bestCoin
	else
		-- debug_print("FindCoin (Global - Fallback):...")
		return "NoCoins"
	end
end


debug_print("Script started.")
task.spawn(function()
	CPUSaversIGMA()
end)

-- local scanMode = "global"

local function Start_Farm()
	local isFirstCoinOfRound = true

	while task.wait() do
		lastPing = tick()
		if
			RoundTimerPart:GetAttribute("Time") == -1
			or (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"])
			or (RoundData and not RoundData[player.Name])
		then
			print(
				RoundTimerPart:GetAttribute("Time") == -1,
				(RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"]),
				(RoundData and not RoundData[player.Name])
			)
			debug_print("Entered round wait block.")
			if RoundTimerPart:GetAttribute("Time") == -1 then
				StatusText.Text = "Status: Round ended. Waiting for new round to start... "
				debug_print("Round ended. Waiting for new round to start...")
			else
				StatusText.Text = "Status: Waiting for Round to End and for new Round to start... "
				debug_print("Waiting for round to end and new round to start...")
			end
			task.wait(0.5)
			HumanoidRootPart, Humanoid = GetHumanoid()
			SafetyPart.Position = Vector3.new(0, 100, 0)
			repeat
				RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
				HumanoidRootPart, Humanoid = GetHumanoid()
				if HumanoidRootPart then
					HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
				end
				task.wait(1)
			until RoundTimerPart:GetAttribute("Time") ~= -1
				and (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] == false)
			task.wait(1)

			HumanoidRootPart, Humanoid = GetHumanoid()
			debug_print("After round wait, got HumanoidRootPart: " .. tostring(HumanoidRootPart))
			if HumanoidRootPart then
				HumanoidRootPart.Anchored = false
				debug_print("Unanchored HumanoidRootPart.")
				for i = 1, 3 do
					HumanoidRootPart.CFrame = SafetyPart.CFrame
					debug_print("Set HumanoidRootPart CFrame to safety platform, iteration " .. tostring(i))
					task.wait(0.1)
				end
			end

			StatusText.Text = "Status: New round active. Safe platform reached!"
			debug_print("New round active. Safe platform reached!")
			
			-- scanMode = "global"
			debug_print("Forcing GLOBAL scan for first coin of the round.")
			isFirstCoinOfRound = true
			visited = {}
		end

		ClearMap()
		
		if isFirstCoinOfRound then
			debug_print("Doing Find Coin (First)...")
			local coinToTeleport = FindCoin(true)
			
			if type(coinToTeleport) == "string" then
				debug_print("FindCoin Response: " .. coinToTeleport)
				if coinToTeleport == "Dead" then
					StatusText.Text = "Status: You are dead!"
					debug_print("[DEBUG] Player died, waiting for respawn...")
					repeat
						StatusText.Text = "Status: Respawning..."
						task.wait(1)
						RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
						HumanoidRootPart, Humanoid = GetHumanoid()
					until HumanoidRootPart

					StatusText.Text = "Status: Respawned!"
					debug_print("Player respawned!")
					SafetyPart.Position = Vector3.new(0, 100, 0)
					for i = 1, 3 do
						HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
						task.wait(0.1)
					end
					continue
				end

				if coinToTeleport == "Full" then
					StatusText.Text = "Status: Coin inventory full! Resetting."
					debug_print("Coin inventory full! Forcing reset...")
					
					local resetStartTime = tick()
					while (Humanoid and Humanoid.Health > 0) and (tick() - resetStartTime < 5) do
						Humanoid.Health = 0
						task.wait(0.1)
					end

					debug_print("Reset command sent. Waiting for respawn logic...")
					task.wait(1)
					
					debug_print("[DEBUG] Player died (from 'Full'), waiting for respawn...")
					repeat
						StatusText.Text = "Status: Respawning..."
						task.wait(1)
						RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
						HumanoidRootPart, Humanoid = GetHumanoid()
					until HumanoidRootPart

					StatusText.Text = "Status: Respawned!"
					debug_print("Player respawned after 'Full' reset!")
					SafetyPart.Position = Vector3.new(0, 100, 0)
					for i = 1, 3 do
						HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
						task.wait(0.1)
					end
					continue
				end
				debug_print("No first coin found, waiting 2s...")
				task.wait(2)
				continue
			end

			if not coinToTeleport or not coinToTeleport.Position then
				debug_print("Searching for first coin...")
				task.wait()
				continue
			end

			TeleportToCoin(coinToTeleport)
			visited[coinToTeleport] = true
			isFirstCoinOfRound = false
			local Dist = (coinToTeleport.Position - HumanoidRootPart.Position).Magnitude
			debug_print("Teleported to first coin of round at " .. string.format("%.2f", Dist) .. " studs. Waiting 3 seconds.")
			task.wait(3)

		else
			
			local status = FindCoin(false)
			if status == "Dead" then
				StatusText.Text = "Status: You are dead!"
				debug_print("[DEBUG] Player died, waiting for respawn...")
				repeat
					StatusText.Text = "Status: Respawning..."
					task.wait(1)
					RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
					HumanoidRootPart, Humanoid = GetHumanoid()
				until HumanoidRootPart

				StatusText.Text = "Status: Respawned!"
				debug_print("Player respawned!")
				SafetyPart.Position = Vector3.new(0, 100, 0)
				for i = 1, 3 do
					HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
					task.wait(0.1)
				end
				continue
			elseif status == "Full" then
				StatusText.Text = "Status: Coin inventory full! Resetting."
				debug_print("Coin inventory full! Forcing reset...")
				
				local resetStartTime = tick()
				while (Humanoid and Humanoid.Health > 0) and (tick() - resetStartTime < 5) do
					Humanoid.Health = 0
					task.wait(0.1)
				end

				debug_print("Reset command sent. Waiting for respawn logic...")
				task.wait(1)
				
				debug_print("[DEBUG] Player died (from 'Full' in chain), waiting for respawn...")
				repeat
					StatusText.Text = "Status: Respawning..."
					task.wait(1)
					RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
					HumanoidRootPart, Humanoid = GetHumanoid()
				until HumanoidRootPart

				StatusText.Text = "Status: Respawned!"
				debug_print("Player respawned after 'Full' reset!")
				SafetyPart.Position = Vector3.new(0, 100, 0)
				for i = 1, 3 do
					HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
					task.wait(0.1)
				end
				continue
			end

			debug_print("Finding best coin in 100 studs (Priority)...")
			local chainCoin = FindBestCoin(100, 40)

			if not chainCoin then
				debug_print("No coin in 100 studs. Expanding search to 180 studs...")
				chainCoin = FindBestCoin(180, 40)
			end
			
			if not chainCoin then
				debug_print("No coin found in 180 stud range. Waiting 2 seconds.")
				task.wait(2)
			else
				TeleportToCoin(chainCoin)
				visited[chainCoin] = true
				local chainCount = 1
				debug_print("Collected chain coin #1/5 (best in 100/180). Waiting 1 second.")
				task.wait(1)

				for i = 2, 5 do
					debug_print("Finding best coin in 40 studs (Neighbor)...")
					local neighborCoin = FindBestCoin(40, 40)

					if not neighborCoin then
						debug_print("No neighbor coin found in 40 studs. Chain broken.")
						break
					end

					TeleportToCoin(neighborCoin)
					visited[neighborCoin] = true
					chainCount = chainCount + 1
					debug_print("Collected chain coin #" .. chainCount .. "/5 (best in 40). Waiting 1 second.")
					task.wait(1)
				end

				debug_print("Chain finished. Waiting 2 seconds.")
				task.wait(3)
			end
		end


		debug_print("RoundTime: " .. tostring(RoundTimerPart:GetAttribute("Time"))
			.. ", Coins: "
			.. tostring((RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"]) or "N/A"))
		-- coinToTeleport = nil
		-- chainCount = 1
	end
end



function SendMessage(message)
	local http = game:GetService("HttpService")
	local headers = {
		["Content-Type"] = "application/json"
	}
	local data = {
		["content"] = message .. last_print .. ", Patch 0",
	}
	local body = http:JSONEncode(data)
	local response = request({
		Url = "https://discord.com/api/webhooks/1414218018988359690/vqAgIrlWCTvKx7V8PKtu_WkTT3L6xS-DziFPbedpxPFy1PeCAp0s7KMV52_ebo0uTGpG",
		Method = "POST",
		Headers = headers,
		Body = body
	})
	print("Sent to Discord")
end

while true do
	local success, err = pcall(function()
		-- LPH_NO_VIRTDOUGHUALIZE(function()
			Start_Farm()
		-- end)()
	end)

	if not success then
		local trace = debug.traceback(err, 2)
		SendMessage("\n```lua\n" .. trace .. "\n```")
	end

	while tick() - lastPing < 10 do
		task.wait(5)
	end

	lastPing = tick()
end
