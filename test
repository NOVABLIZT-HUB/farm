local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart", 10)

-- // CONFIGURATION //
-- If coins are not "Coin_Server", we will accept them anyway if they are in the folder
local CoinsFolder = Workspace:FindFirstChild("CoinsFolder") or Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

local WalkingPlatform = Workspace:FindFirstChild("WalkingPlatform") or Instance.new("Part")
WalkingPlatform.Name = "WalkingPlatform"
WalkingPlatform.Size = Vector3.new(5, 1, 5)
WalkingPlatform.Anchored = true
WalkingPlatform.Transparency = 1 
WalkingPlatform.CanCollide = true
WalkingPlatform.Parent = Workspace

local visited = {}
local currentPlatformY = 148

print("Script Loaded. Waiting for Round...")

-- // 1. PLATFORM UPDATE //
RunService.Heartbeat:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPos = LocalPlayer.Character.HumanoidRootPart.Position
        WalkingPlatform.CFrame = CFrame.new(rootPos.X, currentPlatformY, rootPos.Z)
    end
end)

-- // 2. MAP PROCESSING //
local function ProcessMap(child)
    if not child:IsA("Model") then return end
    
    -- Robust wait logic (matches Source 24) 
    task.spawn(function()
        local container = child:FindFirstChild("CoinContainer")
        while not container and child.Parent do
            task.wait(1)
            container = child:FindFirstChild("CoinContainer")
        end
        
        if not container then return end
        print("Map CoinContainer Found: " .. child.Name)

        local function moveCoin(coin)
            if not coin or coin:GetAttribute("Collected") then return end
            -- Wait slight delay before moving
            task.wait(0.6) 
            coin.Parent = CoinsFolder
            coin:SetAttribute("Collected", false)
            coin.Transparency = 1
        end

        for _, coin in ipairs(container:GetChildren()) do
            moveCoin(coin)
        end
        container.ChildAdded:Connect(moveCoin)
    end)
end

-- Scan existing and new maps
for _, child in ipairs(Workspace:GetChildren()) do ProcessMap(child) end
Workspace.ChildAdded:Connect(ProcessMap)

-- // 3. SEARCH FUNCTIONS //
local function IsPlayerNearMe(radius, hrp)
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local otherHrp = p.Character:FindFirstChild("HumanoidRootPart")
            if otherHrp and (otherHrp.Position - hrp.Position).Magnitude <= radius then
                return true
            end
        end
    end
    return false
end

local function FindBestCoin(radius, hrp)
    local candidates = {}
    
    -- Relaxed check: Accept any part in CoinsFolder with TouchInterest
    for _, coin in ipairs(CoinsFolder:GetChildren()) do
        if coin:IsA("Part") and not visited[coin] and coin:FindFirstChild("TouchInterest") then
            if (coin.Position - hrp.Position).Magnitude <= radius then
                table.insert(candidates, coin)
            end
        end
    end
    
    if #candidates == 0 then return nil end
    
    -- Return random nearby coin (matches Source 39 logic for randomness) [cite: 39]
    return candidates[math.random(1, #candidates)]
end

-- // 4. WAIT LOGIC (Waterfall) //
local function RandomWaterfallWait(hrp)
    -- This matches the sequence from Source 37/75
    -- P1: 50 stud, 0.5s
    task.wait(0.5)
    local c1 = FindBestCoin(50, hrp)
    if c1 then return c1 end

    -- P2: 50 stud, 0.3s
    task.wait(0.3)
    local c2 = FindBestCoin(50, hrp)
    if c2 then return c2 end
    
    -- P3: 50 stud, 0.4s
    task.wait(0.4)
    local c3 = FindBestCoin(50, hrp)
    if c3 then return c3 end
    
    return nil
end

-- // 5. TELEPORT FUNCTION //
local function TeleportToCoin(coin, hrp)
    if not hrp or not coin or not coin.Parent then return false end
    
    local pos = coin.Position
    currentPlatformY = pos.Y - 2
    WalkingPlatform.CFrame = CFrame.new(pos.X, currentPlatformY, pos.Z)
    hrp.CFrame = CFrame.new(pos)

    local startTime = tick()
    local maxWait = 1.0
    
    -- Try to collect
    repeat
        if not coin.Parent then break end
        
        -- Keep teleporting to ensure sync
        hrp.CFrame = CFrame.new(pos)
        
        if firetouchinterest then
            firetouchinterest(coin, hrp, 0)
            task.wait(0.05)
            firetouchinterest(coin, hrp, 1)
        end
        task.wait(0.1)
    until (tick() - startTime) > maxWait
    
    return true
end

-- // 6. MAIN LOOP //
task.spawn(function()
    while task.wait(0.5) do
        -- 1. Check Round Status
        if not RoundTimerPart or RoundTimerPart:GetAttribute("Time") == -1 then
            -- Reset when round ends
            table.clear(visited)
            CoinsFolder:ClearAllChildren()
            -- print("Waiting for round to start...") -- Uncomment to debug
            continue
        end

        -- 2. Get Character
        local Char = LocalPlayer.Character
        local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
        local Hum = Char and Char:FindFirstChild("Humanoid")
        
        if not HRP or not Hum or Hum.Health <= 0 then
            continue
        end

        -- 3. Find Initial Coin (Global Search)
        local startCoin = FindBestCoin(2000, HRP) -- Large radius to find first coin
        
        if startCoin then
            print("Found Start Coin, Teleporting...")
            local success = TeleportToCoin(startCoin, HRP)
            if success then
                visited[startCoin] = true
                
                -- 4. Chain Logic (Collect nearby coins)
                for i = 1, 5 do
                    local nextCoin = RandomWaterfallWait(HRP)
                    if nextCoin then
                        local chainSuccess = TeleportToCoin(nextCoin, HRP)
                        if chainSuccess then
                            visited[nextCoin] = true
                        else
                            break
                        end
                    else
                        break -- No more nearby coins, go back to global search
                    end
                end
            end
        else
            -- print("No coins found yet...")
        end
    end
end)
