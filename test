if _G.Start then
	print("Script is already running.")
	return
end

_G.Start = true

local Default_Config = {
	["CPU Saver"] = true,

	["Auto Open"] = {
		["Enabled"] = false,
		["Crate"] = "",
	},

	["Webhook"] = {
		["URL"] = "",
		["UserID"] = "",
		["Only Good Webhook"] = false,
	},

	["Other"] = {
		["Auto Prestige"] = true,
		["Auto Restart on Update"] = false,
		["Auto Craft"] = false,
	},
	
	["Event"] = {
		["Auto Do Battle Pass"] = true,
	},

    -- [[ NEW CONFIG OPTION ]]
    ["ServerHop"] = {
        ["SortOrder"] = "Asc", -- "Asc" = Server Cũ/Ít người (Thường dùng), "Desc" = Server Mới/Đông hơn
    },

	["Misc"] = {
		["FARM_MURDERER_SHERIF_WINS"] = true,
		["STOP_MURDERER_AFTER_KILLS"] = 20,
		["FPS"] = 3,

		["AutoShutdown"] = {
			["Mode"] = 1,  -- 1 = hop, 2 = close
            ["Minutes"] = 60, -- Sends the x minutes for checking Coins
            ["MinCoins"] = 600, -- Min Coins needed to have after x minutes
			["Every Minutes"] = 0 -- Every x minutes force
        },
	}
}

local function mergeConfig(default, user)
	if type(default) ~= "table" then
		return user
	end
	user = user or {}
	for k, v in pairs(default) do
		if type(v) == "table" then
			user[k] = mergeConfig(v, user[k])
		elseif user[k] == nil then
			user[k] = v
		end
	end
	return user
end

local cfg = (getgenv and getgenv().Config) or _G.Config or {}
cfg = mergeConfig(Default_Config, cfg)

local Version = "v2.4.6 Optimized RAM\n"
local NewestVersion
local usernameRevealed = false
local ChromaAnimation = false
local last_print = ""

local SessionCrates = 0
local TotalStagesBought = 0
local TotalWeapons = 0
local TotalGodlies, TotalChromas = 0, 0

local TotalRoundswithout30coinsplus = 0

local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Terrain = Workspace:WaitForChild("Terrain")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local PhysicsService = game:GetService("PhysicsService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

local Api = "https://games.roblox.com/v1/games/"
local PlaceId = game.PlaceId
-- Removing static definition, now dynamic in GetTargetServers
-- local _servers = Api .. PlaceId .. "/servers/Public?sortOrder=Asc&limit=100&excludeFullGames=true"

local headers = {
	["Content-Type"] = "application/json",
	["Cookie"] = ".ROBLOSECURITY=_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|" -- Insert cookie here if needed
}

local map = nil
local knife = nil
local gun = nil
local GoodPeople = {}
local visited = {}
local AllCoins = {} 

-- [[ LOGIC: LAZY SCAN & REFRESH ]]
local ServerHopData = {
    -- REMOVED PriorityIds
    BackupIds = {},   -- Stores ALL valid servers (<12 players)
	LastFetchTime = 0,
	HopCount = 0,
	WaitTime = 300 -- 5 minutes refresh
}

-- [[ Forward Declaration for SmartServerHop so it can be used in updatePlayerInfo ]]
local SmartServerHop

local FailFarmCount = 0 
local PlayerPositions = {}
local TeleportThreshold = 50


repeat
	task.wait(0.3)
until game:IsLoaded()
	and game.Players.LocalPlayer.Character
	and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	and Workspace:FindFirstChild("Lobby")

if cfg["CPU Saver"] then
	task.spawn(function()
		while task.wait(5) do
			setfpscap(cfg["Misc"]["FPS"])
		end
	end)
end

task.spawn(function()
	if cfg["Other"]["Auto Restart on Update"] then
		NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
		while task.wait(600) do
			NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
			if NewestVersion ~= Version then
				-- Logic for restart could go here
			end
		end
	end
end)

-- Clean up unnecessary Workspace objects
local ObjectsToClean = {
    "Lobby", "WeaponDisplays", "PetContainer", "EffectLoader", "ServerStatus", "GameSettings"
}
for _, objName in ipairs(ObjectsToClean) do
    if Workspace:FindFirstChild(objName) then
        Workspace:FindFirstChild(objName):Destroy()
    end
end

-- Set up player and round references
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
local Humanoid = character:WaitForChild("Humanoid")
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local Database = ReplicatedStorage:WaitForChild("Database")
local Sync = Database:WaitForChild("Sync")


task.spawn(function()
	local GC = getconnections or get_signal_cons

	if GC then
		for i, v in pairs(GC(player.Idled)) do
			if v.Disable then
				v:Disable()
			elseif v.Disconnect then
				v:Disconnect()
			end
		end
	end

	player.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)
end)


local Modules = ReplicatedStorage:WaitForChild("Modules")
local SharedServices = ReplicatedStorage:WaitForChild("SharedServices")

local LevelModule = require(Modules.LevelModule)
local EventInfoService = require(SharedServices.EventInfoService)


local GodlyList = {}
local ChromaList = {}

for _, BoxData in pairs(require(Sync.MysteryBox)) do
	if not BoxData.Godly then
		for _, Item in pairs(BoxData.GodlyTable) do
			table.insert(GodlyList, Item)
		end
	elseif type(BoxData.Godly) == "string" then
		table.insert(GodlyList, BoxData.Godly)
	end
	if BoxData.ChromaTable then
		for _, Item in pairs(BoxData.ChromaTable) do
			table.insert(ChromaList, Item)
		end
	end
end

local RoundData = Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
local Data = require(Modules.ProfileData)

local StartedCoins = 0
local StartedStage = 0
local Event = nil
local iseEventActive = false

Event = EventInfoService:GetCurrentEvent()
iseEventActive = Event ~= nil

if iseEventActive then
	StartedCoins = Data.Materials.Owned[EventInfoService.GetEventCurrency()] or 0
else
	StartedCoins = Data.Materials.Owned["Coins"] or 0
end

if iseEventActive then
	StartedStage = Data[Event.Title].CurrentTier or 0
end


local PlayerLevel, NextLevelXP = LevelModule.GetLevel(Data.NewXP)
local OwnedWeapons = Data["Weapons"]["Owned"]
local totalCoins = StartedCoins

local CoinsFolder = Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

-- [[ UPDATED PLATFORM LOGIC ]] --
local WalkingPlatform = Instance.new("Part")
WalkingPlatform.Name = "WalkingPlatform"
WalkingPlatform.Size = Vector3.new(5, 1, 5) -- [[ CHANGED TO 5x5 ]] --
WalkingPlatform.Anchored = true
WalkingPlatform.Transparency = 1 -- Invisible
WalkingPlatform.CanCollide = true
WalkingPlatform.Parent = Workspace

-- Initialize Platform Height variable (Default Safe Height - 2)
local currentPlatformY = 148 

-- Loop to move platform horizontally (X/Z) but keep Y Fixed
RunService.Heartbeat:Connect(function()
	if HumanoidRootPart then
		local rootPos = HumanoidRootPart.Position
		WalkingPlatform.CFrame = CFrame.new(rootPos.X, currentPlatformY, rootPos.Z)
	end
end)

HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)

-- [[ GUI CREATION ]] --
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local RoleDisplay = Instance.new("TextLabel")
local PrestigeLabel = Instance.new("TextLabel")
local LevelLabel = Instance.new("TextLabel")
local Title = Instance.new("TextLabel")
local TimerLabel = Instance.new("TextLabel")
local RevealUsernameButton = Instance.new("TextButton")
local Logo = Instance.new("ImageButton")
local StatusText = Instance.new("TextLabel")
local TotalGodlyLabel = Instance.new("TextLabel")
local TotalWeaponsLabel = Instance.new("TextLabel")
local TotalChromasLabel = Instance.new("TextLabel")
local CurrentCoinsLabel = Instance.new("TextLabel")
local RoundCoinsLabel = Instance.new("TextLabel")
local SessionCoinsLabel = Instance.new("TextLabel")
local VersionLabel = Instance.new("TextLabel")

ScreenGui.Parent = CoreGui
ScreenGui.IgnoreGuiInset = true

MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.new(0, 0, 0)
MainFrame.Size = UDim2.new(1, 0, 1, 0)

if cfg["CPU Saver"] then
	MainFrame.BackgroundTransparency = 0
else
	MainFrame.BackgroundTransparency = 0.5
end

-- Helper for GUI properties
local function setupLabel(label, pos, size, text)
    label.Parent = MainFrame
    label.BackgroundTransparency = 1.000
    label.Position = pos
    label.Size = size
    label.Font = Enum.Font.FredokaOne
    label.Text = text
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextScaled = true
end

setupLabel(RoleDisplay, UDim2.new(0.39165011, 0, 0.172029704, 0), UDim2.new(0.200000018, 0, 0.100000001, 0), "Role: Innocent (Placeholder)")
setupLabel(PrestigeLabel, UDim2.new(0.390987396, 0, 0.376237631, 0), UDim2.new(0.200000018, 0, 0.0960000008, 0), "Prestige: 0")
setupLabel(LevelLabel, UDim2.new(0.39165011, 0, 0.27722773, 0), UDim2.new(0.25, 0, 0.0962871313, 0), "Level: 0")
setupLabel(Title, UDim2.new(0.274353892, 0, 0.0284653474, 0), UDim2.new(0.450629562, 0, 0.128712878, 0), "Hasty MM2 Coin Farmer")
setupLabel(TimerLabel, UDim2.new(0.25, 0, 0.8, 0), UDim2.new(0.6, 0, 0.15, 0), "Time Farming: 00:00:00")
setupLabel(StatusText, UDim2.new(0.259112, 0, 0.560643554, 0), UDim2.new(0.465871423, 0, 0.126237631, 0), "Status: Loading")
setupLabel(TotalGodlyLabel, UDim2.new(0.0240000002, 100, 0.27722773, 0), UDim2.new(0.200000033, 0, 0.0962871313, 0), "Godly: 0")
setupLabel(TotalWeaponsLabel, UDim2.new(0.0240000002, 100, 0.376237631, 0), UDim2.new(0.200000018, 0, 0.0960000008, 0), "Total: 0")
setupLabel(TotalChromasLabel, UDim2.new(0.0240000002, 100, 0.172029704, 0), UDim2.new(0.200000018, 0, 0.100000001, 0), "Chromas: 0")
setupLabel(CurrentCoinsLabel, UDim2.new(0.665341198, 0, 0.16707921, 0), UDim2.new(0.281510949, 0, 0.100000001, 0), "Current Coins: 0")
setupLabel(RoundCoinsLabel, UDim2.new(0.665341198, 0, 0.375, 0), UDim2.new(0.281510949, 0, 0.100000001, 0), "Round Coins: 0")
setupLabel(SessionCoinsLabel, UDim2.new(0.665341198, 0, 0.272277236, 0), UDim2.new(0.281510949, 0, 0.100000001, 0), "Session Coins: 0")

RevealUsernameButton.Parent = MainFrame
RevealUsernameButton.BackgroundTransparency = 1.000
RevealUsernameButton.Position = UDim2.new(0.258805811, 0, 0.756079197, 0)
RevealUsernameButton.Size = UDim2.new(0.465871423, 0, 0.074257426, 0)
RevealUsernameButton.Font = Enum.Font.FredokaOne
RevealUsernameButton.Text = "Reveal Username"
RevealUsernameButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RevealUsernameButton.TextScaled = true

Logo.Parent = MainFrame
Logo.Size = UDim2.new(0, 100, 0, 100)
Logo.Image = "rbxassetid://72063995210355"

VersionLabel.Parent = MainFrame
VersionLabel.BackgroundTransparency = 1.0
VersionLabel.Position = UDim2.new(0.85, 0, 0.95, 0)
VersionLabel.Size = UDim2.new(0.15, 0, 0.05, 0)
VersionLabel.Font = Enum.Font.SourceSansBold
VersionLabel.Text = Version
VersionLabel.TextColor3 = Color3.new(1, 1, 1)
VersionLabel.TextScaled = true

RevealUsernameButton.MouseButton1Click:Connect(function()
	if not usernameRevealed then
		RevealUsernameButton.Text = "Username: " .. player.Name
		usernameRevealed = true
	else
		RevealUsernameButton.Text = "Reveal Username"
		usernameRevealed = false
	end
end)

consolecreate("DEBUG")
local function debug_print(...)
	last_print = ...
	if string.find(..., "Status:") or string.find(..., "Collected") then
		consoleprint("[" .. player.Name .. "] " .. ... .. "\n")
	end
end

local function CPUSaversIGMA()
	if not cfg["CPU Saver"] then
		return
	end

	local StartTime = tick()

	Terrain.WaterReflectance = 0
	Terrain.WaterTransparency = 1
	Terrain.WaterWaveSize = 0
	Terrain.WaterWaveSpeed = 0

	Lighting.Brightness = 0
	Lighting.GlobalShadows = false
	Lighting.FogStart = 0
	Lighting.FogEnd = math.huge
	Lighting.ClockTime = 12
	Lighting.Ambient = Color3.new(1, 1, 1)
	Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
	Lighting.ExposureCompensation = 0
	Lighting.ShadowSoftness = 0

	if sethiddenproperty then
		sethiddenproperty(Lighting, "Technology", Enum.Technology.Compatibility)
		sethiddenproperty(Terrain, "Decoration", false)
		sethiddenproperty(Workspace, "StreamingEnabled", true)
		sethiddenproperty(Workspace, "StreamingPauseMode", Enum.StreamingPauseMode.ClientPhysicsPause)
		sethiddenproperty(Players, "CharacterAutoLoads", false)
	else
		warn("sethiddenproperty not available.")
	end

	SoundService.RespectFilteringEnabled = true
	SoundService:SetListener(Enum.ListenerType.Camera)
	SoundService.AmbientReverb = Enum.ReverbType.NoReverb

	game:SetAttribute("DataModelMeshStreaming", false)
	ReplicatedStorage:SetAttribute("ReplicateInstanceDestroy", false)

	RunService:Set3dRenderingEnabled(false)
	settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

	player.PlayerGui:Destroy()
	player.PlayerScripts:Destroy()

	local success, err = pcall(function()
		RunService:UnbindFromRenderStep("Humanoid")
		RunService:UnbindFromRenderStep("Animation")
	end)

	local Services_To_Clear = {
		game:GetService("Stats"),
		Lighting,
		CoreGui,
		game:GetService("RobloxReplicatedStorage")
	}

	for _, Service in ipairs(Services_To_Clear) do
		for _, package in ipairs(Service:GetChildren()) do
			if package == ScreenGui then
				continue
			end
			pcall(function()
				package:Destroy()
			end)
		end
	end

    -- [[ RAM OPTIMIZATION: PERIODIC CLEANER INSTEAD OF EVENT LISTENERS ]]
    task.spawn(function()
        while task.wait(3) do -- Clean every 3 seconds
            pcall(function()
                for _, child in ipairs(Workspace:GetChildren()) do
                    if child.Name == "ThrowingKnife" or child.Name == "Firefly" or child.Name == "Footsteps" then
                        child:Destroy()
                        continue
                    end
                    
                    -- Protect Important Things
                    if child.Name == "CoinsFolder" or child.Name == "WalkingPlatform" or child:IsA("Camera") or child.Name == player.Name or child:IsA("Terrain") then
                        continue
                    end

                    -- Destroy Map Parts
                    if child:IsA("Model") or child:IsA("Part") or child:IsA("MeshPart") then
                        if child:FindFirstChild("Humanoid") then
                            continue
                        end
                         pcall(function() child:Destroy() end)
                    end
                end
            end)
        end
    end)
    -- removed player tracking events here for brevity/optimization as seen in original code logic
	print("Script completed. Took " .. (tick() - StartTime) .. " seconds.")
end

local function SendMessageEMBED(url, embed)
	local data = {
		["embeds"] = {
			{
				["title"] = embed.title,
				["description"] = embed.description,
				["color"] = embed.color,
				["fields"] = embed.fields,
				["timestamp"] = embed.timestamp,
				["footer"] = {
					["text"] = embed.footer.text,
				},
			},
		},
	}
	request({
		Url = url,
		Method = "POST",
		Headers = headers,
		Body = HttpService:JSONEncode(data),
	})
end

local function SendMessageWithEmbedAndPing(embed)
	local data = {
		["content"] = "<@" .. cfg["Webhook"]["UserID"] .. ">",
		["embeds"] = {
			{
				["title"] = embed.title,
				["description"] = embed.description,
				["color"] = embed.color,
				["fields"] = embed.fields,
				["footer"] = {
					["text"] = embed.footer.text,
				},
			},
		},
	}
	request({
		Url = cfg["Webhook"]["URL"],
		Method = "POST",
		Headers = headers,
		Body = HttpService:JSONEncode(data),
	})
end

local tries = 0
local ready = false
local StartHumanoid = tick()
local GetHumanoidConn = nil

local function GetHumanoid()
	character = player.Character
	tries = 0

	while tries < 60 do
		character = character or player.Character
		if character then
			HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
			Humanoid = character:FindFirstChild("Humanoid")
			if HumanoidRootPart and Humanoid then
				return HumanoidRootPart, Humanoid
			end
		end

		ready = false
		GetHumanoidConn = player.CharacterAdded:Connect(function(c)
			character = c
			ready = true
		end)

		StartHumanoid = tick()
		while not ready and tick() - StartHumanoid < 1 do
			wait(0.05)
		end

		if GetHumanoidConn then
			GetHumanoidConn:Disconnect()
			GetHumanoidConn = nil
		end

		tries = tries + 1
		task.wait(0.3)
	end

	return nil, nil
end

local startTime = os.time()
local function updateTimer()
	TimerLabel.Text = string.format(
		"Time Farming: %02d:%02d:%02d",
		math.floor((os.time() - startTime) / 3600),
		math.floor(((os.time() - startTime) % 3600) / 60),
		(os.time() - startTime) % 60
	)
end


local function getCurrentCoins()
	if Event == nil then
		return Data["Materials"]["Owned"]["Coins"] or 0
	else
		return Data["Materials"]["Owned"][EventInfoService.GetEventCurrency()] or 0
	end
end

local lastShutdownCheck = tick()
local TotalSessionChecks = 1

local function updatePlayerInfo()
	Data = require(Modules.ProfileData)
	RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()

	PlayerLevel, NextLevelXP = LevelModule.GetLevel(Data.NewXP)
	LevelLabel.Text = "Level: " .. PlayerLevel .. " (" .. Data.NewXP .. "/" .. NextLevelXP .. ")"
	PrestigeLabel.Text = "Prestige: " .. player:GetAttribute("Prestige")

	totalCoins = getCurrentCoins()
	CurrentCoinsLabel.Text = "Current Coins: " .. totalCoins


	OwnedWeapons = Data["Weapons"]["Owned"] or {}

	TotalWeapons = 0
	TotalGodlies, TotalChromas = 0, 0

	for weapon, weaponamount in pairs(Data["Weapons"]["Owned"] or {}) do
		if table.find(GodlyList, weapon) then
			TotalGodlies = TotalGodlies + weaponamount
		elseif table.find(ChromaList, weapon) then
			TotalChromas = TotalChromas + weaponamount
		end
		TotalWeapons = TotalWeapons + weaponamount
	end

	TotalChromasLabel.Text = "Chromas: " .. tostring(TotalChromas)
	TotalGodlyLabel.Text = "Godly: " .. tostring(TotalGodlies)
	TotalWeaponsLabel.Text = "Total: " .. tostring(TotalWeapons)

	if TotalChromas >= 1 and not ChromaAnimation then
		ChromaAnimation = true
		task.spawn(function()
			while ChromaAnimation do
				for i = 0, 1, 0.01 do
					MainFrame.BackgroundColor3 = Color3.fromHSV(i, 1, 1)
					task.wait(0.3)
				end
			end
		end)
	end

	if cfg["Auto Open"]["Enabled"] and tonumber(Data["Materials"]["Owned"][EventInfoService.GetEventCurrency()] or 0) >= 800 then
		local Item = ReplicatedStorage.Remotes.Shop.OpenCrate:InvokeServer(cfg["Auto Open"]["Crate"], "MysteryBox", "Candies2025")

		if
			Item
			and type(cfg["Webhook"]["URL"]) == "string"
			and string.find(cfg["Webhook"]["URL"], "https://discord.com/api/webhooks")
		then
			SessionCrates = SessionCrates + 1
			debug_print("Crate opened. Item received: " .. (Item or "Unknown"))
			Data = require(Modules.ProfileData)

			TotalWeapons = #Data["Weapons"]["Owned"] or #{}
			TotalGodlies, TotalChromas = 0, 0
			for weapon, weaponamount in pairs(Data["Weapons"]["Owned"] or {}) do
				if table.find(GodlyList, weapon) then
					TotalGodlies = TotalGodlies + weaponamount
				elseif table.find(ChromaList, weapon) then
					TotalChromas = TotalChromas + weaponamount
				end
			end
			local embed = {
				title = "",
				description = "",
				color = 65280,
				fields = {},
				footer = {
					text = "Hasty MM2 Coin Farmer",
				},
				timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
			}

			table.insert(embed.fields, { name = "Item", value = tostring(Item), inline = false })
			table.insert(embed.fields, { name = "Username", value = tostring(player.Name), inline = false })
			table.insert(embed.fields, { name = "Total Godlies", value = tostring(TotalGodlies), inline = true })
			table.insert(embed.fields, { name = "Total Chromas", value = tostring(TotalChromas), inline = true })

			if table.find(GodlyList, Item) then
				embed.color = 16776960
				embed.title = "Crate Opened with a Godly Item"
				embed.description = "Congratulations! You received a rare Godly Item."
				SendMessageWithEmbedAndPing(embed)
			elseif table.find(ChromaList, Item) then
				embed.color = 16711935
				embed.title = "Crate Opened with a Chroma Item"
				embed.description = "Nice! You received an exclusive Chroma Item."
				SendMessageWithEmbedAndPing(embed)
			else
				if not cfg["Webhook"]["Only Good Webhook"] then
					embed.title = "Crate Opened with an Ordinary Item"
					embed.description = "You received a normal item."
					embed.color = 65280
					SendMessageEMBED(cfg["Webhook"]["URL"], embed)
				end
			end
			embed = nil
			Item = nil
		end
	end

	if cfg["Other"]["Auto Prestige"] then
		if PlayerLevel == 100 and player:GetAttribute("Prestige") < 10 then
			Remotes.Inventory.Prestige:FireServer()
			PrestigeLabel.Text = "Prestige: " .. player:GetAttribute("Prestige")
		end
	end


	local function ClaimRewards()
		for tierStr, rewardData in pairs(EventInfoService:GetBattlePass().Rewards) do
			if tonumber(tierStr) <= Data[Event.Title].CurrentTier and not Data[Event.Title].ClaimedRewards[tonumber(tierStr)] and rewardData.ItemID ~= "" then
				task.wait(0)
				EventInfoService:GetEventRemotes().ClaimBattlePassReward:FireServer(tonumber(tierStr))
			end
		end
	end
	if cfg["Event"]["Auto Do Battle Pass"] and iseEventActive then
		ClaimRewards()
		if tonumber(totalCoins) >= tonumber(800) then
			if Data[Event.Title].CurrentTier ~= 25 then
				Remotes.Events.Generic.BuyTiers:FireServer(1)
				task.wait(0)
				Data = require(Modules.ProfileData)
				task.wait(0)
				if StartedStage < Data[Event.Title].CurrentTier then
					TotalStagesBought = Data[Event.Title].CurrentTier - StartedStage
				end
				ClaimRewards()
			elseif Data[Event.Title].CurrentTier == 25 and tonumber(totalCoins) >= tonumber(90000) then
				Remotes.Events.Generic.BuyFinalReward:FireServer()
				task.wait(0)
				if type(cfg["Webhook"]["URL"]) == "string" and string.find(cfg["Webhook"]["URL"], "https://discord.com/api/webhooks") then
					for weapon, weaponamount in pairs(OwnedWeapons) do
						if table.find(GodlyList, weapon) then
							TotalGodlies = TotalGodlies + weaponamount
						elseif table.find(ChromaList, weapon) then
							TotalChromas = TotalChromas + weaponamount
						end
						TotalWeapons = TotalWeapons + weaponamount
					end
					local embed = {
						title = "Claimed Battle Pass Tier 25",
						description = "",
						color = 65280,
						fields = {},
						footer = {
							text = "Hasty MM2 Coin Farmer",
						},
						timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
					}
					table.insert(embed.fields, { name = "Item", value = tostring("Raygun"), inline = false })
					table.insert(embed.fields, { name = "Username", value = tostring(player.Name), inline = false })
					table.insert(embed.fields, { name = "Total Godlies", value = tostring(TotalGodlies), inline = true })
					table.insert(embed.fields, { name = "Total Chromas", value = tostring(TotalChromas), inline = true })
					SendMessageWithEmbedAndPing(embed)
				end
			end
		end
		ClaimRewards()
	end

	SessionCoinsLabel.Text = "Session Coins: " .. totalCoins - StartedCoins + (SessionCrates * 1000) + (TotalStagesBought * 800)
	
	if cfg["Misc"]["AutoShutdown"]["Minutes"] ~= 0 and cfg["Misc"]["AutoShutdown"]["MinCoins"] ~= 0 then
	    if tick() - lastShutdownCheck >= cfg["Misc"]["AutoShutdown"]["Minutes"] * 60 then
	        lastShutdownCheck = tick()
	        
            -- [[ AUTO SHUTDOWN FIX: Compare ACTUAL EARNED COINS ]]
            local coinsEarned = totalCoins - StartedCoins
	        if coinsEarned < (cfg["Misc"]["AutoShutdown"]["MinCoins"] * TotalSessionChecks) then
             
                print("AutoShutdown Triggered: Earned " .. coinsEarned .. ", expected " .. (cfg["Misc"]["AutoShutdown"]["MinCoins"] * TotalSessionChecks))
	            if cfg["Misc"]["AutoShutdown"]["Mode"] == 1 then
					-- [[ UPDATED TO USE SMART HOP (Force Backup = true) ]]
					if SmartServerHop then
						SmartServerHop(true)
					end
				else
					game:Shutdown()
				end
	        end
            TotalSessionChecks = TotalSessionChecks + 1
	    end
	end

	if cfg["Misc"]["AutoShutdown"]["Every Minutes"] ~= 0 then
        if os.time() - startTime >= cfg["Misc"]["AutoShutdown"]["Every Minutes"] * 60 then
			if SmartServerHop then
				SmartServerHop(true)
			end
	    end
	end

	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] then
		RoleDisplay.Text = "Role: " .. (RoundData[player.Name]["Role"] or "Unknown")
		RoundCoinsLabel.Text = "Round Coins: " .. RoundData[player.Name]["Coins"] or 0
	else
		RoleDisplay.Text = "Role: No Round"
		RoundCoinsLabel.Text = "Round Coins: 0"
	end
	Data = nil
	PlayerLevel, NextLevelXP = nil, nil
end

task.spawn(function()
	while true do
		updateTimer()
		updatePlayerInfo()
		task.wait(.5)
		task.spawn(function()
			RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
		end)
		task.wait(.5)
	end
end)


local function ClearMap()
	if map then
		for _, child in ipairs(map:GetChildren()) do
			if child:IsA("Model") and child.Name ~= "CoinContainer" then
				child.Parent = nil
			end
		end
	end
end

local function ProccessMap(child)
	if not child:GetAttribute("MapID") then return end

	repeat task.wait(0) until child:FindFirstChild("CoinContainer")

	print("Map found: " .. child.Name)

	local conn = nil
	-- Reset AllCoins here, but ensure global reference is used
	AllCoins = {}
	
	conn = child.CoinContainer.ChildAdded:Connect(function(coin)
		if not coin or coin:GetAttribute("Collected") then return end

		table.insert(AllCoins, coin)

		task.wait(0.5)
		if coin:FindFirstChild("CoinVisual") and cfg["CPU Saver"] then
			coin.CoinVisual:Destroy()
		end

		coin.Parent = CoinsFolder
		coin:SetAttribute("Collected", false)
		coin.Transparency = 1
	end)

    -- RAM OPTIMIZATION: Reduced busy wait frequency from wait(0) to wait(1)
	while child.CoinContainer and child.CoinContainer.Parent == child do
		task.wait(1)
	end

	if conn then conn:Disconnect() end
end


task.spawn(function()
	for _, child in ipairs(Workspace:GetChildren()) do
		ProccessMap(child)
	end
end)


local MapMove_handler = Workspace.ChildAdded:Connect(function(child)
	ProccessMap(child)
end)

local lastPing = tick()

-- [[ HELPER: GET ACTUAL COINS FOR VERIFICATION ]]
local function GetActualCoins()
	local d = require(Modules.ProfileData)
    if iseEventActive then
        return d.Materials.Owned[EventInfoService.GetEventCurrency()] or 0
    else
        return d.Materials.Owned["Coins"] or 0
    end
end

--// Teleport to Coin
-- [[ LOGIC: 3x FAIL FARM & TRUE COLLECTION CHECK ]]
local function TeleportToCoin(coin)
	if not HumanoidRootPart or not Humanoid or not coin or not coin.Position then
		return false -- Failed
	end

	if not coin:FindFirstChild("TouchInterest") then
		return false -- Already collected or invalid
	end

    -- Record coins BEFORE collection
    local coinsBefore = GetActualCoins()

	local pos = coin.Position
	local currentPos = HumanoidRootPart.Position
	local directionVector = (pos - currentPos)

    -- [[ PLATFORM SNAP UPDATE: ALWAYS -2 ]] --
    currentPlatformY = pos.Y - 2
    WalkingPlatform.CFrame = CFrame.new(pos.X, currentPlatformY, pos.Z)

	if directionVector.Magnitude < 0.1 then
		HumanoidRootPart.CFrame = CFrame.new(pos)
	else
		local directionUnit = directionVector.Unit
		local lookAtPos = pos + (directionUnit * 5)
		HumanoidRootPart.CFrame = CFrame.new(pos, lookAtPos)
	end

	local startTime = tick()
	
	repeat
		firetouchinterest(coin, HumanoidRootPart, 0)
		task.wait(0.3)
		firetouchinterest(coin, HumanoidRootPart, 1)
		task.wait(0.3)
		
		if not coin or not coin:FindFirstChild("TouchInterest") then
			break
		end
	until (tick() - startTime) > 1 
    
    -- Record coins AFTER collection
    local coinsAfter = GetActualCoins()

    if coinsAfter > coinsBefore then
        return true -- Success: We got the coin
    else
        return false -- Fail: Coin gone but we didn't get it (Someone else took it)
    end
end

local function FindBestCoin(searchRadius, neighborRadius)
	if not HumanoidRootPart then return nil end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then return nil end

	local coinsInRadius = {}
	for _, coin in ipairs(allValidCoins) do
		local dist = (coin.Position - HumanoidRootPart.Position).Magnitude
		if dist <= searchRadius then
			table.insert(coinsInRadius, coin)
		end
	end

	if #coinsInRadius == 0 then
		return nil
	end

	local bestCoin = nil
	local maxNeighbors = -1

	for _, coin in ipairs(coinsInRadius) do
		local neighborCount = 0
		for _, otherCoin in ipairs(allValidCoins) do
			if coin ~= otherCoin then
				local dist = (coin.Position - otherCoin.Position).Magnitude
				if dist <= neighborRadius then
					neighborCount = neighborCount + 1
				end
			end
		end

		if neighborCount > maxNeighbors then
			maxNeighbors = neighborCount
			bestCoin = coin
		end
	end

	return bestCoin
end

local function FindNearestUnvisitedCoin(radius)
	if not HumanoidRootPart then return nil end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then return nil end

	local nearestCoin = nil
	local minDistance = radius + 0.1

	for _, coin in ipairs(allValidCoins) do
		local dist = (coin.Position - HumanoidRootPart.Position).Magnitude
		if dist < minDistance then
			minDistance = dist
			nearestCoin = coin
		end
	end

	return nearestCoin
end

local function FindRandomUnvisitedCoin(radius)
	if not HumanoidRootPart then return nil end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then return nil end

	local coinsInRadius = {}
	for _, coin in ipairs(allValidCoins) do
		local dist = (coin.Position - HumanoidRootPart.Position).Magnitude
		if dist <= radius then
			table.insert(coinsInRadius, coin)
		end
	end

	if #coinsInRadius == 0 then
		return nil
	end

	return coinsInRadius[math.random(1, #coinsInRadius)]
end

-- [[ UPDATED IsPlayerNearMe (Robust Version) ]]
local function IsPlayerNearMe(checkRadius)
	if not HumanoidRootPart then return false end
	local myPos = HumanoidRootPart.Position
	
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= player then
			local char = p.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChild("Humanoid")
				
				-- Check Valid and Alive
				if hrp and hum and hum.Health > 0 then
					local dist = (hrp.Position - myPos).Magnitude
					if dist <= checkRadius then
						return true 
					end
				end
			end
		end
	end
	
	return false
end


local function CountPlayersNearPosition(position, checkRadius)
	local playerCount = 0
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= player then
			local char = p.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChild("Humanoid")
				if hrp and hum and hum.Health > 0 then
					local dist = (position - hrp.Position).Magnitude
					if dist < checkRadius then
						playerCount = playerCount + 1
					end
				end
			end
		end
	end
	return playerCount
end


local function RandomWaterfallWait(
	proximityRadius1, minWait1, maxWait1,
	proximityRadius2, minWait2, maxWait2,
	proximityRadius3, minWait3, maxWait3,
	finalRadius, finalWait
)
	
	-- 1. Wait, Scan 15 stud
	local wait1 = minWait1 + math.random() * (maxWait1 - minWait1)
	task.wait(wait1)
	
	local coin15
	local isPlayerClose_P1 = IsPlayerNearMe(proximityRadius1)
	
	if isPlayerClose_P1 then
		coin15 = FindRandomUnvisitedCoin(proximityRadius1)
	else
		coin15 = FindNearestUnvisitedCoin(proximityRadius1)
	end

	if coin15 then
		return coin15 -- P1
	end

	-- 2. Wait, Scan 25 stud
	local wait2 = minWait2 + math.random() * (maxWait2 - minWait2)
	task.wait(wait2)
	
	local coin25
	local isPlayerClose_P2 = IsPlayerNearMe(proximityRadius2)
	
	if isPlayerClose_P2 then
		coin25 = FindRandomUnvisitedCoin(proximityRadius2)
	else
		coin25 = FindNearestUnvisitedCoin(proximityRadius2)
	end

	if coin25 then
		return coin25 -- P2
	end

	-- 3. Wait, Scan 35 stud
	local wait3 = minWait3 + math.random() * (maxWait3 - minWait3)
	task.wait(wait3)
	
	local coin35
	local isPlayerClose_P3 = IsPlayerNearMe(proximityRadius3)
	
	if isPlayerClose_P3 then
		coin35 = FindRandomUnvisitedCoin(proximityRadius3)
	else
		coin35 = FindNearestUnvisitedCoin(proximityRadius3)
	end

	if coin35 then
		return coin35 -- P3
	end

	-- 4. Wait 0.5s, Scan 50 stud
	task.wait(finalWait)
	
	local coin50
	local isPlayerClose_P4 = IsPlayerNearMe(finalRadius)
	
	if isPlayerClose_P4 then
		coin50 = FindRandomUnvisitedCoin(finalRadius)
	else
		coin50 = FindBestCoin(finalRadius, 40)
	end

	if coin50 then
		return coin50 -- P4
	end

	return nil
end


local function FindNextChainCoin()
	-- 1. Search 50 studs
	local coin50
	local isPlayerClose_50 = IsPlayerNearMe(50)
	
	if isPlayerClose_50 then
		coin50 = FindRandomUnvisitedCoin(50)
	else
		coin50 = FindNearestUnvisitedCoin(50)
	end

	if coin50 then
		return coin50 -- Found coin in 50 studs
	end

	-- 2. Wait 0.5s, then search 100 studs
	task.wait(0.5)
	
	local coin100
	local isPlayerClose_100 = IsPlayerNearMe(100)
	
	if isPlayerClose_100 then
		coin100 = FindRandomUnvisitedCoin(100)
	else
		coin100 = FindBestCoin(100, 40)
	end

	if coin100 then
		return coin100 -- Found coin in 100 studs
	end

	return nil
end


local function FindCoin(isFirst)
	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] then
		return "Dead"
	end

	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] == 40 then
		return "Full"
	end

	if not HumanoidRootPart or not AllCoins then
		return nil
	end

	local allValidCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin.Parent and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") and not visited[coin] then
			table.insert(allValidCoins, coin)
		end
	end

	if #allValidCoins == 0 then
		return "NoCoins"
	end
	
	if isFirst then
		-- [[ LOGIC UPDATE: Use IsPlayerNearMe(50) to decide Safe or Random ]]
		local isPlayerClose_First = IsPlayerNearMe(50)
		
		if isPlayerClose_First then
			return allValidCoins[math.random(1, #allValidCoins)]
		else
			return allValidCoins[math.random(1, #allValidCoins)]
		end
	else
		local coinsInRadius = {}
		for _, coin in ipairs(allValidCoins) do
			if (coin.Position - HumanoidRootPart.Position).Magnitude <= 50 then
				table.insert(coinsInRadius, coin)
			end
		end

		if #coinsInRadius == 0 then
			return "NoCoins"
		end
		
		if IsPlayerNearMe(50) then
			 return coinsInRadius[math.random(1, #coinsInRadius)]
		end

		local bestCoin = nil
		local minPlayerCount = math.huge

		for _, coin in ipairs(coinsInRadius) do
			local playerCount = CountPlayersNearPosition(coin.Position, 50)
			
			if playerCount < minPlayerCount then
				minPlayerCount = playerCount
				bestCoin = coin
			end

			if minPlayerCount == 0 then
				break
			end
		end

		if bestCoin then
			return bestCoin
		else
			return "NoCoins" 
		end
	end
end

debug_print("Script started.")
task.spawn(function()
	CPUSaversIGMA()
end)

-- [[ LOGIC: 4+ TELEPORTERS & TARGET PLAYERS UPDATE ]]
local function GetTargetServers()
	local currentJobId = game.JobId
	local allValidServers = {}
    local cursor = nil
    local pagesScanned = 0
    local maxPages = 20 -- Scan up to 20 pages (approx 2000 servers)
	
	debug_print("Đang quét sâu danh sách servers (".. maxPages .." trang)...")
	
    repeat
        local success, data = pcall(function()
            local sort = cfg["ServerHop"]["SortOrder"] or "Asc"
            local url = Api .. PlaceId .. "/servers/Public?sortOrder=" .. sort .. "&limit=100&excludeFullGames=true"
            
            if cursor then
                url = url .. "&cursor=" .. cursor
            end

            local response
            if game.HttpGet then
                response = game:HttpGet(url)
            elseif HttpService.GetAsync then
                response = HttpService:GetAsync(url, true)
            else
                local requestFunc = syn and syn.request or request
                if requestFunc then
                    local result = requestFunc({
                        Url = url,
                        Method = "GET"
                    })
                    response = result.Body
                end
            end
            
            if response then
                return HttpService:JSONDecode(response)
            end
            return nil
        end)
        
        if success and data and data.data then
            for _, server in ipairs(data.data) do
                if server.id ~= currentJobId then
                    table.insert(allValidServers, server.id)
                end
            end
            
            cursor = data.nextPageCursor
            pagesScanned = pagesScanned + 1
            -- debug_print("Page " .. pagesScanned .. ": Found " .. #data.data .. " servers.")
        else
            warn("Lỗi khi quét trang " .. (pagesScanned + 1))
            break
        end

        if cursor then
            task.wait(0.25) -- Prevent rate limit (Safe delay)
        end
    until not cursor or pagesScanned >= maxPages
	
	debug_print("Quét hoàn tất! Tổng server tìm thấy: " .. #allValidServers)
	
    -- Return empty priority list (deprecated) and the big list
	return {}, allValidServers 
end

-- [[ LOGIC: LAZY SCAN & REFRESH ]]
local function FetchTargetJobIds()
	local currentTime = tick()
	
	if (currentTime - ServerHopData.LastFetchTime) > ServerHopData.WaitTime or (#ServerHopData.BackupIds == 0) then
        debug_print("Server list older than 5 mins or empty. Forcing refresh.")
        -- ServerHopData.PriorityIds = {} -- REMOVED
        ServerHopData.BackupIds = {}
    else
        return true
    end
	
	local prio, backup = GetTargetServers()
	
	if #backup == 0 then
		warn("Không tìm thấy server nào phù hợp")
		return false
	end
	
	-- ServerHopData.PriorityIds = prio -- REMOVED
    ServerHopData.BackupIds = backup
	
	ServerHopData.LastFetchTime = currentTime
	debug_print("Đã cập nhật danh sách server.")
	return true
end

-- [[ LOGIC: 3x FAIL FARM - PRIORITY & BACKUP ]]
SmartServerHop = function(forceAnyBackup)
	FetchTargetJobIds()
	
	-- [[ LOGIC CHANGE: REMOVED PRIORITY HOP STEP ]]
    -- Now directly hops to RANDOM server from valid list (BackupIds)
    
    -- Main Hop: Random from valid list
    if #ServerHopData.BackupIds > 0 then
        debug_print("Đang hop đến server Random (từ danh sách server tìm được)...")
        if StatusText then StatusText.Text = "Status: Hopping to Random Server..." end

        local randomIndex = math.random(1, #ServerHopData.BackupIds)
        local jobId = ServerHopData.BackupIds[randomIndex]

        table.remove(ServerHopData.BackupIds, randomIndex)

        local hopSuccess, hopError = pcall(function()
            TeleportService:TeleportToPlaceInstance(PlaceId, jobId, player)
        end)

        if hopSuccess then return true end
    end

    -- Last Resort: Random Hop API
    if forceAnyBackup then
         debug_print("Last Resort: Random Hop API.")
         local PlaceId = game.PlaceId
         local Api = "https://games.roblox.com/v1/games/"
     
         local _servers = Api..PlaceId.."/servers/Public?sortOrder=Desc&limit=100"
         local function ListServers(cursor)
             local Raw = game:HttpGet(_servers .. ((cursor and "&cursor="..cursor) or ""))
             return HttpService:JSONDecode(Raw)
         end
         
         local Server, Next;
         repeat
             local Servers = ListServers(Next)
             Server = Servers.data[math.random(1, #Servers.data)]
             Next = Servers.nextPageCursor
         until Server
         
         TeleportService:TeleportToPlaceInstance(PlaceId, Server.id, player)
         return true
    end
    
    return false
end

-- [[ NEW: STUCK DETECTION / AUTO REJOIN LOGIC ]]
task.spawn(function()
    local Stuck_LastPosition = Vector3.new(0, 0, 0)
    local Stuck_Timer = tick()
    local TeleportService = game:GetService("TeleportService")
    
    while task.wait(1) do
        local success, err = pcall(function()
            local RoundTimerPart = Workspace:FindFirstChild("RoundTimerPart")
            
            -- CHECK 1: Match must be active (Time != -1)
            local isMatchActive = false
            if RoundTimerPart and RoundTimerPart:GetAttribute("Time") and RoundTimerPart:GetAttribute("Time") ~= -1 then
                isMatchActive = true
            end

            -- CHECK 2: Player must be alive
            local isAlive = false
            if RoundData and RoundData[player.Name] and not RoundData[player.Name]["Dead"] then
                isAlive = true
            end
            
            -- If In Match AND Alive -> Check Movement
            if isMatchActive and isAlive then
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local currentPos = player.Character.HumanoidRootPart.Position
                    local dist = (currentPos - Stuck_LastPosition).Magnitude
                    
                    if dist > 3 then 
                        -- Player Moved
                        Stuck_Timer = tick()
                        Stuck_LastPosition = currentPos
                    else
                        -- Player Not Moving
                        if (tick() - Stuck_Timer) >= 10 then
                            print("PLAYER STUCK FOR 10 SECONDS IN MATCH - REJOINING SAME SERVER...")
                            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
                            task.wait(10)
                        end
                    end
                end
            else
                -- Reset timer if not in match or dead
                Stuck_Timer = tick()
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    Stuck_LastPosition = player.Character.HumanoidRootPart.Position
                end
            end
        end)
    end
end)

local function Start_Farm()
	local isFirstCoinOfRound = true

	while task.wait(0) do
		lastPing = tick()
		if
			RoundTimerPart:GetAttribute("Time") == -1
			or (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"])
			or (RoundData and not RoundData[player.Name])
		then
			if RoundTimerPart:GetAttribute("Time") == -1 then
				StatusText.Text = "Status: Round ended. Waiting for new round to start... "
			else
				StatusText.Text = "Status: Waiting for Round to End and for new Round to start... "
			end
			task.wait(0.5)
			HumanoidRootPart, Humanoid = GetHumanoid()

			repeat
				RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
				HumanoidRootPart, Humanoid = GetHumanoid()
				if HumanoidRootPart then
                    -- UPDATED: Keep player in safe sky position, platform will follow
                    HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)
                    -- [[ PLATFORM SNAP UPDATE: 150 - 2 = 148 ]]
                    currentPlatformY = 148 
                    WalkingPlatform.CFrame = CFrame.new(0, currentPlatformY, 0)
				end
				task.wait(1)
			until RoundTimerPart:GetAttribute("Time") ~= -1
				and (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] == false)
			task.wait(1)

			HumanoidRootPart, Humanoid = GetHumanoid()
			if HumanoidRootPart then
				HumanoidRootPart.Anchored = false
				for i = 1, 3 do
                    HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)
					task.wait(0.1)
				end
			end

			StatusText.Text = "Status: New round active. Safe platform reached!"
			debug_print("Status: New round active. Safe platform reached!")
			
			isFirstCoinOfRound = true
            -- OPTIMIZATION: Clear Memory Tables & Force Garbage Collection
			visited = {} 
            CoinsFolder:ClearAllChildren()
            FailFarmCount = 0 
            collectgarbage("collect") 
		end

		ClearMap()
		
		if isFirstCoinOfRound then
			local coinToTeleport = FindCoin(true)
			
			if type(coinToTeleport) == "string" then
				if coinToTeleport == "Dead" then
					StatusText.Text = "Status: You are dead!"
					repeat
						StatusText.Text = "Status: Respawning..."
						task.wait(1)
						RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
						HumanoidRootPart, Humanoid = GetHumanoid()
					until HumanoidRootPart

					StatusText.Text = "Status: Respawned!"
					debug_print("Player respawned!")
					for i = 1, 3 do
						HumanoidRootPart.CFrame = CFrame.new(0, 150, 0) 
						task.wait(0.1)
					end
					continue
				end

				if coinToTeleport == "Full" then
					StatusText.Text = "Status: Coin inventory full! Resetting."
					debug_print("Coin inventory full! Forcing reset...")
					
					local resetStartTime = tick()
					while (Humanoid and Humanoid.Health > 0) and (tick() - resetStartTime < 5) do
						Humanoid.Health = 0
						task.wait(0.1)
					end

					task.wait(1)
					
					repeat
						StatusText.Text = "Status: Respawning..."
						task.wait(1)
						RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
						HumanoidRootPart, Humanoid = GetHumanoid()
					until HumanoidRootPart

					StatusText.Text = "Status: Respawned!"
					debug_print("Player respawned after 'Full' reset!")
					for i = 1, 3 do
						HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)
						task.wait(0.1)
					end
					continue
				end
				task.wait(1)
				continue
			end

			if not coinToTeleport or not coinToTeleport.Position then
				task.wait(0.3)
				continue
			end

			local success = TeleportToCoin(coinToTeleport)
            -- [[ LOGIC: 10x FAIL FARM CHECK ]]
            if success then
                visited[coinToTeleport] = true
                isFirstCoinOfRound = false
                local Dist = (coinToTeleport.Position - HumanoidRootPart.Position).Magnitude
                debug_print("Teleported to first coin of round at " .. string.format("%.2f", Dist) .. " studs. Waiting 3 seconds.")
                task.wait(2)
            else
                FailFarmCount = FailFarmCount + 1
                debug_print("Failed to collect first coin. Round Fail Count: " .. FailFarmCount)
                if FailFarmCount >= 10 then
                    debug_print("10x Fail Farm (Round). Hopping...")
                    SmartServerHop(true)
                end
            end

		else
			
			local status = FindCoin(false)
			if status == "Dead" then
				StatusText.Text = "Status: You are dead!"
				repeat
					StatusText.Text = "Status: Respawning..."
					task.wait(1)
					RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
					HumanoidRootPart, Humanoid = GetHumanoid()
				until HumanoidRootPart

				StatusText.Text = "Status: Respawned!"
				debug_print("Player respawned!")
				for i = 1, 3 do
					HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)
					task.wait(0.1)
				end
				continue
			elseif status == "Full" then
				StatusText.Text = "Status: Coin inventory full! Resetting."
				debug_print("Coin inventory full! Forcing reset...")
				
				local resetStartTime = tick()
				while (Humanoid and Humanoid.Health > 0) and (tick() - resetStartTime < 5) do
					Humanoid.Health = 0
					task.wait(0.1)
				end

				task.wait(1)
				
				repeat
					StatusText.Text = "Status: Respawning..."
					task.wait(1)
					RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
					HumanoidRootPart, Humanoid = GetHumanoid()
				until HumanoidRootPart

				StatusText.Text = "Status: Respawned!"
				debug_print("Player respawned after 'Full' reset!")
				for i = 1, 3 do
					HumanoidRootPart.CFrame = CFrame.new(0, 150, 0)
					task.wait(0.1)
				end
				continue
			end

			local chainCoin = FindNextChainCoin()
			
			if not chainCoin then
				task.wait(2)
			else
				local success = TeleportToCoin(chainCoin)
                
                -- [[ LOGIC: 10x FAIL FARM CHECK ]]
                if success then
                    visited[chainCoin] = true
                   
                    local chainCount = 1
                    debug_print("Collected coin")
                    
                    for i = 2, 5 do
                        -- [FIX] Check if bag is full BEFORE trying next coin
                        if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] >= 40 then
                            break -- Bag full, stop chain
                        end

                        local nextCoin = RandomWaterfallWait(
                            50, 0.5, 0.5,
                            50, 0.2, 0.4,
                            50, 0.3, 0.6,
                            50, 0.2, 0.4
                        )

                        if not nextCoin then
                            break
                        else
                            local chainSuccess = TeleportToCoin(nextCoin)
                          
                            if chainSuccess then
                                visited[nextCoin] = true
                                chainCount = chainCount + 1
                                debug_print("Collected coin")
                                
                                -- [FIX] Check if bag became full after collection
                                if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] >= 40 then
                                    break 
                                end
                            else
                                -- [FIX] If fail, double check if it's because bag is full
                                local currentData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
                                if currentData and currentData[player.Name] and currentData[player.Name]["Coins"] >= 40 then
                                     -- Not a failure, just full bag
                                     break 
                                else
                                    FailFarmCount = FailFarmCount + 1
                                    if FailFarmCount >= 10 then
                                        debug_print("10x Fail Farm (Round). Hopping...")
                                        SmartServerHop(true)
                                        break -- Exit loop to hop
                                     end
                                end
                            end
                        end
                    end

                    if chainCount > 0 then
                        task.wait(0.5)
                    end
                else
                    FailFarmCount = FailFarmCount + 1
                    debug_print("Failed to collect chain start coin. Round Fail Count: " .. FailFarmCount)
                    if FailFarmCount >= 10 then
                        debug_print("10x Fail Farm (Round). Hopping...")
                        SmartServerHop(true)
                    end
                end
			end
		end
	end
end


function SendMessage(message)
	local http = game:GetService("HttpService")
	local headers = {
		["Content-Type"] = "application/json"
	}
	local data = {
		["content"] = message .. last_print .. ", Patch 0",
	}
	local body = http:JSONEncode(data)
	local response = request({
		Url = "https://discord.com/api/webhooks/1414218018988359690/vqAgIrlWCTvKx7V8PKtu_WkTT3L6xS-DziFPbedpxPFy1PeCAp0s7KMV52_ebo0uTGpG",
		Method = "POST",
		Headers = headers,
		Body = body
	})
	print("Sent to Discord")
end

while true do
	local success, err = pcall(function()
		Start_Farm()
	end)

	if not success then
		local trace = debug.traceback(err, 2)
		SendMessage("\n```lua\n" .. trace .. "\n```")
	end

	while tick() - lastPing < 10 do
		task.wait(5)
	end
	setfflag("NextGenReplicatorEnabledWrite4", "true")
	lastPing = tick()
end
