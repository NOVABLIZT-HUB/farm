local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- // VARIABLES //
local CoinsFolder = Workspace:FindFirstChild("CoinsFolder") or Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

local WalkingPlatform = Workspace:FindFirstChild("WalkingPlatform") or Instance.new("Part")
WalkingPlatform.Name = "WalkingPlatform"
WalkingPlatform.Size = Vector3.new(5, 1, 5)
WalkingPlatform.Anchored = true
WalkingPlatform.Transparency = 1 
WalkingPlatform.CanCollide = true
WalkingPlatform.Parent = Workspace

local visited = {} -- vital for the wait logic to know what we grabbed
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart", 10)

-- // 1. PLATFORM LOGIC //
local currentPlatformY = 148
RunService.Heartbeat:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPos = LocalPlayer.Character.HumanoidRootPart.Position
        WalkingPlatform.CFrame = CFrame.new(rootPos.X, currentPlatformY, rootPos.Z)
    end
end)

-- // 2. MAP & COIN PROCESSING //
local function ProcessMap(child)
    if not child:IsA("Model") then return end
    -- Wait for container briefly
    local container = child:WaitForChild("CoinContainer", 2)
    if not container then return end

    print("Map found: " .. child.Name)
    
    local function moveCoin(coin)
        if not coin or coin:GetAttribute("Collected") then return end
        task.wait(0.6) -- Slight delay as per original 
        coin.Parent = CoinsFolder
        coin:SetAttribute("Collected", false)
        coin.Transparency = 1
    end

    for _, coin in ipairs(container:GetChildren()) do
        moveCoin(coin)
    end

    container.ChildAdded:Connect(moveCoin)
end

for _, child in ipairs(Workspace:GetChildren()) do ProcessMap(child) end
Workspace.ChildAdded:Connect(ProcessMap)

-- // 3. HELPER FUNCTIONS (REQUIRED FOR WAIT LOGIC) //

-- Checks if real players are near to determine "Stealth" vs "Speed" mode 
local function IsPlayerNearMe(checkRadius)
    if not HumanoidRootPart then return false end
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local hrp = p.Character:FindFirstChild("HumanoidRootPart")
            local hum = p.Character:FindFirstChild("Humanoid")
            if hrp and hum and hum.Health > 0 then
                if (hrp.Position - HumanoidRootPart.Position).Magnitude <= checkRadius then
                    return true
                end
            end
        end
    end
    return false
end

local function FindNearestUnvisitedCoin(radius)
    local nearest = nil
    local minDist = radius + 0.1
    for _, coin in ipairs(CoinsFolder:GetChildren()) do
        if coin.Name == "Coin_Server" and not visited[coin] and coin:FindFirstChild("TouchInterest") then
            local dist = (coin.Position - HumanoidRootPart.Position).Magnitude
            if dist < minDist then
                minDist = dist
                nearest = coin
            end
        end
    end
    return nearest
end

local function FindRandomUnvisitedCoin(radius)
    local candidates = {}
    for _, coin in ipairs(CoinsFolder:GetChildren()) do
        if coin.Name == "Coin_Server" and not visited[coin] and coin:FindFirstChild("TouchInterest") then
            if (coin.Position - HumanoidRootPart.Position).Magnitude <= radius then
                table.insert(candidates, coin)
            end
        end
    end
    if #candidates == 0 then return nil end
    return candidates[math.random(1, #candidates)]
end

-- // 4. THE WATERFALL WAIT LOGIC //
-- This is the specific logic you wanted to keep 
local function RandomWaterfallWait(
    proximityRadius1, minWait1, maxWait1,
    proximityRadius2, minWait2, maxWait2,
    proximityRadius3, minWait3, maxWait3,
    finalRadius, finalWait
)
    -- Phase 1
    local wait1 = minWait1 + math.random() * (maxWait1 - minWait1)
    task.wait(wait1)
    
    local coin1
    if IsPlayerNearMe(proximityRadius1) then
        coin1 = FindRandomUnvisitedCoin(proximityRadius1)
    else
        coin1 = FindNearestUnvisitedCoin(proximityRadius1)
    end
    if coin1 then return coin1 end

    -- Phase 2
    local wait2 = minWait2 + math.random() * (maxWait2 - minWait2)
    task.wait(wait2)
    
    local coin2
    if IsPlayerNearMe(proximityRadius2) then
        coin2 = FindRandomUnvisitedCoin(proximityRadius2)
    else
        coin2 = FindNearestUnvisitedCoin(proximityRadius2)
    end
    if coin2 then return coin2 end

    -- Phase 3
    local wait3 = minWait3 + math.random() * (maxWait3 - minWait3)
    task.wait(wait3)
    
    local coin3
    if IsPlayerNearMe(proximityRadius3) then
        coin3 = FindRandomUnvisitedCoin(proximityRadius3)
    else
        coin3 = FindNearestUnvisitedCoin(proximityRadius3)
    end
    if coin3 then return coin3 end

    -- Phase 4 (Final Backup)
    task.wait(finalWait)
    local coinFinal
    if IsPlayerNearMe(finalRadius) then
        coinFinal = FindRandomUnvisitedCoin(finalRadius)
    else
        -- Fallback to nearest if "BestCoin" logic is too heavy
        coinFinal = FindNearestUnvisitedCoin(finalRadius) 
    end
    
    return coinFinal
end

-- // 5. TELEPORT EXECUTION //
local function TeleportToCoin(coin)
    if not HumanoidRootPart or not coin or not coin.Parent then return false end
    
    local pos = coin.Position
    local coinsBefore = 0 -- (You can hook this to GetCurrentPlayerData if you want strict validation)

    -- Update Platform
    currentPlatformY = pos.Y - 2
    WalkingPlatform.CFrame = CFrame.new(pos.X, currentPlatformY, pos.Z)
    
    -- Move Player
    HumanoidRootPart.CFrame = CFrame.new(pos)

    -- Collect 
    local startTime = tick()
    local maxWaitTime = 1.0 
    
    repeat
        if coin and coin.Parent and coin:FindFirstChild("TouchInterest") then
            firetouchinterest(coin, HumanoidRootPart, 0)
            task.wait(0.15)
            firetouchinterest(coin, HumanoidRootPart, 1)
            task.wait(0.15)
        else
            task.wait(0.3) -- Wait out the time if coin disappears early 
        end
    until (tick() - startTime) > maxWaitTime
    
    return true
end

-- // 6. MAIN FARM LOOP //
task.spawn(function()
    while task.wait(0.5) do
        Character = LocalPlayer.Character
        HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart")

        -- Check if Round is Active 
        if not RoundTimerPart or RoundTimerPart:GetAttribute("Time") == -1 then
            visited = {} -- Reset visited on round end
            CoinsFolder:ClearAllChildren()
            task.wait(1)
            continue
        end
        
        -- Start Chain Logic 
        -- 1. Find First Coin
        local firstCoin = FindNearestUnvisitedCoin(1000) -- Find anything on map to start
        
        if firstCoin then
            local success = TeleportToCoin(firstCoin)
            if success then
                visited[firstCoin] = true
                
                -- 2. Enter Chain Loop (The "Wait Logic" Loop) 
                -- This loop tries to grab 4 more coins in quick succession using the waterfall logic
                for i = 1, 5 do
                    -- Fetch coin using the specific timing params from source 
                    local nextCoin = RandomWaterfallWait(
                        50, 0.5, 0.5,   -- P1: 50 stud radius, 0.5s wait
                        50, 0.2, 0.4,   -- P2: 50 stud radius, 0.2-0.4s wait
                        50, 0.3, 0.6,   -- P3: 50 stud radius, 0.3-0.6s wait
                        50, 0.2, 0.4    -- P4: 50 stud radius, 0.2-0.4s wait
                    )

                    if nextCoin then
                        local chainSuccess = TeleportToCoin(nextCoin)
                        if chainSuccess then
                            visited[nextCoin] = true
                        else
                            break -- Break chain if failed
                        end
                    else
                        break -- Break chain if no coin found via waterfall
                    end
                end
            end
        end
    end
end)
