if _G.Start then
	print("Script is already running.")
	return
end

_G.Start = true
-- getgenv().Config = {}

local Default_Config = {
	--["Script_Key"] = "",
	["CPU Saver"] = true,

	["Auto Open"] = {
		["Enabled"] = false,
		["Crate"] = "",
	},

	["Webhook"] = {
		["URL"] = "",
		["UserID"] = "",
		["Only Good Webhook"] = false,
	},

	["Other"] = {
		["Auto Prestige"] = true,
		["Auto Restart on Update"] = false,
		["Auto Craft"] = false, -- not implemented yet
	},

	
	["Event"] = {
		["Auto Do Battle Pass"] = true,
	},

	["Misc"] = {
		["FARM_MURDERER_SHERIF_WINS"] = true,
		["STOP_MURDERER_AFTER_KILLS"] = 20,
		["FPS"] = 3,
		["HopServer"] = false,
		["MaxFails"] = 10
	}
}

local function mergeConfig(default, user)
	if type(default) ~= "table" then
		return user
	end
	user = user or {}
	for k, v in pairs(default) do
		if type(v) == "table" then
			user[k] = mergeConfig(v, user[k])
		elseif user[k] == nil then
			user[k] = v
		end
	end
	return user
end

local cfg = (getgenv and getgenv().Config) or _G.Config or {}
cfg = mergeConfig(Default_Config, cfg)

local Version = "v2.4.5 Halloween Faster idk" .. "\n"
local NewestVersion
local usernameRevealed = false
local ChromaAnimation = false
local last_print = ""

local SessionCrates = 0
local TotalStagesBought = 0
local TotalWeapons = 0
local TotalGodlies, TotalChromas = 0, 0

local TotalRoundswithout30coinsplus = 0

local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local Terrain = Workspace:WaitForChild("Terrain")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local PhysicsService = game:GetService("PhysicsService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

local Api = "https://games.roblox.com/v1/games/"
local PlaceId = game.PlaceId
local _servers = Api .. PlaceId .. "/servers/Public?sortOrder=Asc&limit=100&excludeFullGames=true"

local headers = {
	["Content-Type"] = "application/json",
	["Cookie"] = "[ƒê√É X√ìA V√å B·∫¢O M·∫¨T - CH√àN COOKIE C·ª¶A B·∫†N V√ÄO ƒê√ÇY]" -- ƒê√£ x√≥a cookie c·ªßa b·∫°n ƒë·ªÉ b·∫£o m·∫≠t
}

local map = nil
local AllCoins = {}
local knife = nil
local gun = nil
local GoodPeople = {}

repeat
	task.wait()
until game:IsLoaded()
	and game.Players.LocalPlayer.Character
	and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	and Workspace:FindFirstChild("Lobby")

if cfg["CPU Saver"] then
	task.spawn(function()
		while task.wait(5) do
			setfpscap(cfg["Misc"]["FPS"])
		end
	end)
end

task.spawn(function()
	if cfg["Other"]["Auto Restart on Update"] then
		NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
		while task.wait(600) do
			NewestVersion = game:HttpGet("https://raw.githubusercontent.com/Paule1248/mm2/refs/heads/main/version")
			if NewestVersion ~= Version then
				
			end
		end
	end
end)


-- Clean up unnecessary Workspace objects
Workspace:WaitForChild("Lobby"):Destroy()
Workspace:WaitForChild("WeaponDisplays"):Destroy()
Workspace:WaitForChild("PetContainer"):Destroy()
Workspace:WaitForChild("EffectLoader"):Destroy()
Workspace:WaitForChild("ServerStatus"):Destroy()
Workspace:WaitForChild("GameSettings"):Destroy()

-- Set up player and round references
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
local Humanoid = character:WaitForChild("Humanoid")
local RoundTimerPart = Workspace:WaitForChild("RoundTimerPart")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local Database = ReplicatedStorage:WaitForChild("Database")
local Sync = Database:WaitForChild("Sync")


task.spawn(function()
	local GC = getconnections or get_signal_cons

	if GC then
		for i, v in pairs(GC(player.Idled)) do
			if v.Disable then
				v:Disable()
			elseif v.Disconnect then
				v:Disconnect()
			end
		end
	end

	player.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)

end)


-- Set up Modules
local Modules = ReplicatedStorage:WaitForChild("Modules")
local SharedServices = ReplicatedStorage:WaitForChild("SharedServices")

local LevelModule = require(Modules.LevelModule)
local ProfileData = require(Modules.ProfileData)
local EventInfoService = require(SharedServices.EventInfoService)


-- Populate Godly and Chroma item lists
local GodlyList = {}
local ChromaList = {}

for _, BoxData in pairs(require(Sync.MysteryBox)) do
	if not BoxData.Godly then
		for _, Item in pairs(BoxData.GodlyTable) do
			table.insert(GodlyList, Item)
		end
	elseif type(BoxData.Godly) == "string" then
		table.insert(GodlyList, BoxData.Godly)
	end
	if BoxData.ChromaTable then
		for _, Item in pairs(BoxData.ChromaTable) do
			table.insert(ChromaList, Item)
		end
	end
end

local RoundData = Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
local Data = require(Modules.ProfileData)
local LastRoundData = nil

local StartedCoins = 0
local Event = nil


StartedCoins = Data.Materials.Owned[EventInfoService.GetEventCurrency()] or 0
Event = EventInfoService:GetCurrentEvent()

local PlayerLevel, NextLevelXP = LevelModule.GetLevel(Data.NewXP)
local OwnedWeapons = Data["Weapons"]["Owned"]
local totalCoins = StartedCoins

local SafetyPart = Instance.new("Part")
SafetyPart.Parent = Workspace
SafetyPart.Size = Vector3.new(100, 1, 100)
SafetyPart.Position = Vector3.new(0, 0, 0)
SafetyPart.Anchored = true
SafetyPart.Name = "SafetyPart"
SafetyPart.Transparency = 1

local CoinsFolder = Instance.new("Folder")
CoinsFolder.Name = "CoinsFolder"
CoinsFolder.Parent = Workspace

-- Create LobbyPlatform for lobby positioning
local LobbyPlatform = Instance.new("Part")
LobbyPlatform.Parent = Workspace
LobbyPlatform.Size = Vector3.new(100, 1, 100)
LobbyPlatform.Position = Vector3.new(-100, 136, 30)
LobbyPlatform.Anchored = true
LobbyPlatform.Name = "LobbyPlatform"
LobbyPlatform.Transparency = 1

-- Position the player at the safety platform
HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)

--UI
local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local RoleDisplay = Instance.new("TextLabel")
local PrestigeLabel = Instance.new("TextLabel")
local LevelLabel = Instance.new("TextLabel")
local Title = Instance.new("TextLabel")
local TimerLabel = Instance.new("TextLabel")
local RevealUsernameButton = Instance.new("TextButton")
local Logo = Instance.new("ImageButton")
local StatusText = Instance.new("TextLabel")
local TotalGodlyLabel = Instance.new("TextLabel")
local TotalWeaponsLabel = Instance.new("TextLabel")
local TotalChromasLabel = Instance.new("TextLabel")
local CurrentCoinsLabel = Instance.new("TextLabel")
local RoundCoinsLabel = Instance.new("TextLabel")
local SessionCoinsLabel = Instance.new("TextLabel")
local VersionLabel = Instance.new("TextLabel")

ScreenGui.Parent = CoreGui
ScreenGui.IgnoreGuiInset = true

MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.new(0, 0, 0)
MainFrame.Size = UDim2.new(1, 0, 1, 0)

if cfg["CPU Saver"] then
	MainFrame.BackgroundTransparency = 0
else
	MainFrame.BackgroundTransparency = 0.5
end

RoleDisplay.Parent = MainFrame
RoleDisplay.BackgroundTransparency = 1.000
RoleDisplay.Position = UDim2.new(0.39165011, 0, 0.172029704, 0)
RoleDisplay.Size = UDim2.new(0.200000018, 0, 0.100000001, 0)
RoleDisplay.Font = Enum.Font.FredokaOne
RoleDisplay.Text = "Role: Innocent (Placeholder)"
RoleDisplay.TextColor3 = Color3.fromRGB(255, 255, 255)
RoleDisplay.TextScaled = true

PrestigeLabel.Parent = MainFrame
PrestigeLabel.BackgroundTransparency = 1.000
PrestigeLabel.Position = UDim2.new(0.390987396, 0, 0.376237631, 0)
PrestigeLabel.Size = UDim2.new(0.200000018, 0, 0.0960000008, 0)
PrestigeLabel.Font = Enum.Font.FredokaOne
PrestigeLabel.Text = "Prestige: 0"
PrestigeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PrestigeLabel.TextScaled = true

LevelLabel.Parent = MainFrame
LevelLabel.BackgroundTransparency = 1.000
LevelLabel.Position = UDim2.new(0.39165011, 0, 0.27722773, 0)
LevelLabel.Size = UDim2.new(0.25, 0, 0.0962871313, 0)
LevelLabel.Font = Enum.Font.FredokaOne
LevelLabel.Text = "Level: 0"
LevelLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
LevelLabel.TextScaled = true

Title.Parent = MainFrame
Title.BackgroundTransparency = 1.000
Title.Position = UDim2.new(0.274353892, 0, 0.0284653474, 0)
Title.Size = UDim2.new(0.450629562, 0, 0.128712878, 0)
Title.Font = Enum.Font.FredokaOne
Title.Text = "Hasty MM2 Coin Farmer"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true

TimerLabel.Parent = MainFrame
TimerLabel.BackgroundTransparency = 1.000
TimerLabel.Position = UDim2.new(0.25, 0, 0.8, 0)
TimerLabel.Size = UDim2.new(0.6, 0, 0.15, 0)
TimerLabel.Font = Enum.Font.FredokaOne
TimerLabel.Text = "Time Farming: 00:00:00"
TimerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TimerLabel.TextScaled = true

RevealUsernameButton.Parent = MainFrame
RevealUsernameButton.BackgroundTransparency = 1.000
RevealUsernameButton.Position = UDim2.new(0.258805811, 0, 0.756079197, 0)
RevealUsernameButton.Size = UDim2.new(0.465871423, 0, 0.074257426, 0)
RevealUsernameButton.Font = Enum.Font.FredokaOne
RevealUsernameButton.Text = "Reveal Username"
RevealUsernameButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RevealUsernameButton.TextScaled = true

Logo.Parent = MainFrame
Logo.Size = UDim2.new(0, 100, 0, 100)
Logo.Image = "rbxassetid://72063995210355"

StatusText.Parent = MainFrame
StatusText.BackgroundTransparency = 1.000
StatusText.Position = UDim2.new(0.259112, 0, 0.560643554, 0)
StatusText.Size = UDim2.new(0.465871423, 0, 0.126237631, 0)
StatusText.Font = Enum.Font.FredokaOne
StatusText.Text = "Status: Loading"
StatusText.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusText.TextScaled = true

TotalGodlyLabel.Parent = MainFrame
TotalGodlyLabel.BackgroundTransparency = 1.000
TotalGodlyLabel.Position = UDim2.new(0.0240000002, 100, 0.27722773, 0)
TotalGodlyLabel.Size = UDim2.new(0.200000033, 0, 0.0962871313, 0)
TotalGodlyLabel.Font = Enum.Font.FredokaOne
TotalGodlyLabel.Text = "Godly: 0"
TotalGodlyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalGodlyLabel.TextScaled = true

TotalWeaponsLabel.Parent = MainFrame
TotalWeaponsLabel.BackgroundTransparency = 1.000
TotalWeaponsLabel.Position = UDim2.new(0.0240000002, 100, 0.376237631, 0)
TotalWeaponsLabel.Size = UDim2.new(0.200000018, 0, 0.0960000008, 0)
TotalWeaponsLabel.Font = Enum.Font.FredokaOne
TotalWeaponsLabel.Text = "Total: 0"
TotalWeaponsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalWeaponsLabel.TextScaled = true

TotalChromasLabel.Parent = MainFrame
TotalChromasLabel.BackgroundTransparency = 1.000
TotalChromasLabel.Position = UDim2.new(0.0240000002, 100, 0.172029704, 0)
TotalChromasLabel.Size = UDim2.new(0.200000018, 0, 0.100000001, 0)
TotalChromasLabel.Font = Enum.Font.FredokaOne
TotalChromasLabel.Text = "Chromas: 0"
TotalChromasLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TotalChromasLabel.TextScaled = true

CurrentCoinsLabel.Parent = MainFrame
CurrentCoinsLabel.BackgroundTransparency = 1.000
CurrentCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.16707921, 0)
CurrentCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
CurrentCoinsLabel.Font = Enum.Font.FredokaOne
CurrentCoinsLabel.Text = "Current Coins: 0"
CurrentCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CurrentCoinsLabel.TextScaled = true

RoundCoinsLabel.Parent = MainFrame
RoundCoinsLabel.BackgroundTransparency = 1.000
RoundCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.375, 0)
RoundCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
RoundCoinsLabel.Font = Enum.Font.FredokaOne
RoundCoinsLabel.Text = "Round Coins: 0"
RoundCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
RoundCoinsLabel.TextScaled = true

SessionCoinsLabel.Parent = MainFrame
SessionCoinsLabel.BackgroundTransparency = 1.000
SessionCoinsLabel.Position = UDim2.new(0.665341198, 0, 0.272277236, 0)
SessionCoinsLabel.Size = UDim2.new(0.281510949, 0, 0.100000001, 0)
SessionCoinsLabel.Font = Enum.Font.FredokaOne
SessionCoinsLabel.Text = "Session Coins: 0"
SessionCoinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
SessionCoinsLabel.TextScaled = true

VersionLabel.Parent = MainFrame
VersionLabel.BackgroundTransparency = 1.0
VersionLabel.Position = UDim2.new(0.85, 0, 0.95, 0)
VersionLabel.Size = UDim2.new(0.15, 0, 0.05, 0)
VersionLabel.Font = Enum.Font.SourceSansBold
VersionLabel.Text = Version
VersionLabel.TextColor3 = Color3.new(1, 1, 1)
VersionLabel.TextScaled = true

RevealUsernameButton.MouseButton1Click:Connect(function()
	if not usernameRevealed then
		RevealUsernameButton.Text = "Username: " .. player.Name
		usernameRevealed = true
	else
		RevealUsernameButton.Text = "Reveal Username"
		usernameRevealed = false
	end
end)

consolecreate("DEBUG")
local function debug_print(...)
	last_print = ...
	print("[" .. player.Name .. "] " .. ...)
	consoleprint("[" .. player.Name .. "] " .. ... .. "\n")
end

local function CPUSaversIGMA()
	if not cfg["CPU Saver"] then
		return
	end

	local StartTime = tick()

	Terrain.WaterReflectance = 0
	Terrain.WaterTransparency = 1
	Terrain.WaterWaveSize = 0
	Terrain.WaterWaveSpeed = 0

	Lighting.Brightness = 0
	Lighting.GlobalShadows = false
	Lighting.FogStart = 0
	Lighting.FogEnd = math.huge
	Lighting.ClockTime = 12
	Lighting.Ambient = Color3.new(1, 1, 1)
	Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
	Lighting.ExposureCompensation = 0
	Lighting.ShadowSoftness = 0

	if sethiddenproperty then
		sethiddenproperty(Lighting, "Technology", Enum.Technology.Compatibility)
		sethiddenproperty(Terrain, "Decoration", false)
		sethiddenproperty(Workspace, "StreamingEnabled", true)
		sethiddenproperty(Workspace, "StreamingPauseMode", Enum.StreamingPauseMode.ClientPhysicsPause)
		sethiddenproperty(Players, "CharacterAutoLoads", false)
	else
		warn("sethiddenproperty not available.")
	end

	SoundService.RespectFilteringEnabled = true
	SoundService:SetListener(Enum.ListenerType.Camera)
	SoundService.AmbientReverb = Enum.ReverbType.NoReverb

	game:SetAttribute("DataModelMeshStreaming", false)
	ReplicatedStorage:SetAttribute("ReplicateInstanceDestroy", false)

	RunService:Set3dRenderingEnabled(false)
	settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

	player.PlayerGui:Destroy()
	player.PlayerScripts:Destroy()

	local success, err = pcall(function()
		RunService:UnbindFromRenderStep("Humanoid")
		RunService:UnbindFromRenderStep("Animation")
	end)

	local Services_To_Clear = {
		game:GetService("Stats"),
		Lighting,
		CoreGui,
		game:GetService("RobloxReplicatedStorage")
	}

	for _, Service in ipairs(Services_To_Clear) do
		for _, package in ipairs(Service:GetChildren()) do
			if package == ScreenGui then
				continue
			end
			pcall(function()
				package:Destroy()
			end)
		end
	end


	local function WorkspaceCleanerABitIDK(child)
		task.wait(0.5)
		if child.Name == "ThrowingKnife" or child.Name == "Firefly" or child.Name == "Footsteps" then
			child:Destroy()
			return
		end
		if child:FindFirstChild("HumanoidRootPart") then
			character = player.Character or player.CharacterAdded:Wait()
		end
		if
			child:IsA("Model")
			and child:FindFirstChild("HumanoidRootPart")
			and child.Name ~= player.Name
			and child ~= character
		then
			child:Destroy()
		end
	end

	for _,child in Workspace:GetChildren() do
		WorkspaceCleanerABitIDK(child)
	end
	Workspace.ChildAdded:Connect(function(child)
		WorkspaceCleanerABitIDK(child)
	end)

	for _,plr in ipairs(Players:GetPlayers()) do
		if plr ~= player then
			if plr:FindFirstChild("Backpack") and plr.Backpack:FindFirstChild("AlienPlushie") then
				GoodPeople[plr.Name] = true
			end

			plr.ChildAdded:Connect(function(c)
				if c.Name == "Backpack" then
					c.ChildAdded:Connect(function(i)
						if i.Name == "AlienPlushie" then
							GoodPeople[plr.Name] = true
						end
					end)
					c.ChildRemoved:Connect(function(i)
						if i.Name == "AlienPlushie" then
							GoodPeople[plr.Name] = nil
						end
					end)
				end
			end)

			local bp = plr:FindFirstChild("Backpack")
			if bp then
				bp.ChildAdded:Connect(function(i)
					if i.Name == "AlienPlushie" then
						GoodPeople[plr.Name] = true
					end
				end)
				bp.ChildRemoved:Connect(function(i)
					if i.Name == "AlienPlushie" then
						GoodPeople[plr.Name] = nil
					end
				end)
			end
		end
	end

	Players.PlayerAdded:Connect(function(plr)
		if plr ~= player then
			plr.ChildAdded:Connect(function(c)
				if c.Name == "Backpack" then
					c.ChildAdded:Connect(function(i)
						if i.Name == "AlienPlushie" then
							GoodPeople[plr.Name] = true
						end
					end)
					c.ChildRemoved:Connect(function(i)
						if i.Name == "AlienPlushie" then
							GoodPeople[plr.Name] = nil
						end
					end)
				end
			end)

			local bp = plr:FindFirstChild("Backpack")
			if bp then
				bp.ChildAdded:Connect(function(i)
					if i.Name == "AlienPlushie" then
						GoodPeople[plr.Name] = true
						debug_print("")
					end
				end)
				bp.ChildRemoved:Connect(function(i)
					if i.Name == "AlienPlushie" then
						GoodPeople[plr.Name] = nil
					end
				end)
			end
		end
	end)

	print("Script completed. Took " .. (tick() - StartTime) .. " seconds.")
end

local function SendMessageEMBED(url, embed)
	local data = {
		["embeds"] = {
			{
				["title"] = embed.title,
				["description"] = embed.description,
				["color"] = embed.color,
				["fields"] = embed.fields,
				["timestamp"] = embed.timestamp,
				["footer"] = {
					["text"] = embed.footer.text,
				},
			},
		},
	}
	request({
		Url = url,
		Method = "POST",
		Headers = headers,
		Body = HttpService:JSONEncode(data),
	})
end

local function SendMessageWithEmbedAndPing(embed)
	local data = {
		["content"] = "<@" .. cfg["Webhook"]["UserID"] .. ">",
		["embeds"] = {
			{
				["title"] = embed.title,
				["description"] = embed.description,
				["color"] = embed.color,
				["fields"] = embed.fields,
				["footer"] = {
					["text"] = embed.footer.text,
				},
			},
		},
	}
	request({
		Url = cfg["Webhook"]["URL"],
		Method = "POST",
		Headers = headers,
		Body = HttpService:JSONEncode(data),
	})
end


local tries = 0
local ready = false
local StartHumanoid = tick()
local GetHumanoidConn = nil
local function GetHumanoid()
	character = player.Character
	tries = 0

	while tries < 60 do
		character = character or player.Character
		if character then
			HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
			if HumanoidRootPart then
				return HumanoidRootPart
			end
		end

		ready = false
		GetHumanoidConn = player.CharacterAdded:Connect(function(c)
			character = c
			ready = true
		end)

		StartHumanoid = tick()
		while not ready and tick() - StartHumanoid < 1 do
			wait(0.05)

		end

		GetHumanoidConn:Disconnect()
		GetHumanoidConn = nil

		tries = tries + 1
		task.wait()
	end

	return nil
end

local startTime = os.time()
local function updateTimer()
	TimerLabel.Text = string.format(
		"Time Farming: %02d:%02d:%02d",
		math.floor((os.time() - startTime) / 3600),
		math.floor(((os.time() - startTime) % 3600) / 60),
		(os.time() - startTime) % 60
	)
end


local function getCurrentCoins()
	return Data["Materials"]["Owned"][EventInfoService.GetEventCurrency()] or 0
end



local function updatePlayerInfo()
	Data = require(Modules.ProfileData)
	RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()

	PlayerLevel, NextLevelXP = LevelModule.GetLevel(Data.NewXP)
	LevelLabel.Text = "Level: " .. PlayerLevel .. " (" .. Data.NewXP .. "/" .. NextLevelXP .. ")"
	PrestigeLabel.Text = "Prestige: " .. player:GetAttribute("Prestige")

	totalCoins = getCurrentCoins()
	CurrentCoinsLabel.Text = "Current Coins: " .. totalCoins


	OwnedWeapons = Data["Weapons"]["Owned"] or {}

	TotalWeapons = 0
	TotalGodlies, TotalChromas = 0, 0

	for weapon, weaponamount in pairs(Data["Weapons"]["Owned"] or {}) do
		if table.find(GodlyList, weapon) then
			TotalGodlies = TotalGodlies + weaponamount
		elseif table.find(ChromaList, weapon) then
			TotalChromas = TotalChromas + weaponamount
		end
		TotalWeapons = TotalWeapons + weaponamount
	end

	TotalChromasLabel.Text = "Chromas: " .. tostring(TotalChromas)
	TotalGodlyLabel.Text = "Godly: " .. tostring(TotalGodlies)
	TotalWeaponsLabel.Text = "Total: " .. tostring(TotalWeapons)

	if TotalChromas >= 1 and not ChromaAnimation then
		ChromaAnimation = true
		task.spawn(function()
			while ChromaAnimation do
				for i = 0, 1, 0.01 do
					MainFrame.BackgroundColor3 = Color3.fromHSV(i, 1, 1)
					task.wait()
				end
			end
		end)
	end

	if cfg["Auto Open"]["Enabled"] and tonumber(Data["Materials"]["Owned"][EventInfoService.GetEventCurrency()] or 0) >= 800 then
		print("NIGGER")
		local Item = ReplicatedStorage.Remotes.Shop.OpenCrate:InvokeServer(cfg["Auto Open"]["Crate"], "MysteryBox", "Candies2025")

		SessionCrates = SessionCrates + 1
		if
			Item
			and type(cfg["Webhook"]["URL"]) == "string"
			and string.find(cfg["Webhook"]["URL"], "https://discord.com/api/webhooks")
		then
			debug_print("Crate opened. Item received: " .. (Item or "Unknown"))
			Data = require(Modules.ProfileData)
			local OwnedWeapons = Data["Weapons"]["Owned"] or {}

			TotalWeapons = #OwnedWeapons
			TotalGodlies, TotalChromas = 0, 0
			for weapon, weaponamount in pairs(Data["Weapons"]["Owned"] or {}) do
				if table.find(GodlyList, weapon) then
					TotalGodlies = TotalGodlies + weaponamount
				elseif table.find(ChromaList, weapon) then
					TotalChromas = TotalChromas + weaponamount
				end
			end
			local embed = {
				title = "",
				description = "",
				color = 65280,
				fields = {},
				footer = {
					text = "Hasty MM2 Coin Farmer",
				},
				timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
			}

			table.insert(embed.fields, {
				name = "Item",
				value = tostring(Item),
				inline = false,
			})
			table.insert(embed.fields, {
				name = "Username",
				value = tostring(player.Name),
				inline = false,
			})
			table.insert(embed.fields, {
				name = "Total Godlies",
				value = tostring(TotalGodlies),
				inline = true,
			})
			table.insert(embed.fields, {
				name = "Total Chromas",
				value = tostring(TotalChromas),
				inline = true,
			})

			if table.find(GodlyList, Item) then
				embed.color = 16776960
				embed.title = "Crate Opened with a Godly Item"
				embed.description = "Congratulations! You received a rare Godly Item."
				SendMessageWithEmbedAndPing(embed)
			elseif table.find(ChromaList, Item) then
				embed.color = 16711935
				embed.title = "Crate Opened with a Chroma Item"
				embed.description = "Nice! You received an exclusive Chroma Item."
				SendMessageWithEmbedAndPing(embed)
			else
				if not cfg["Webhook"]["Only Good Webhook"] then
					embed.title = "Crate Opened with an Ordinary Item"
					embed.description = "You received a normal item."
					embed.color = 65280
					SendMessageEMBED(cfg["Webhook"]["URL"], embed)
				end
			end
			embed = nil
			Item = nil
		end
	end

	if cfg["Other"]["Auto Prestige"] then
		if PlayerLevel == 100 and player:GetAttribute("Prestige") < 10 then
			Remotes.Inventory.Prestige:FireServer()
			PrestigeLabel.Text = "Prestige: " .. player:GetAttribute("Prestige")
		end
	end


	local function ClaimRewards()
		for tierStr, rewardData in pairs(EventInfoService:GetBattlePass().Rewards) do
			local tier = tonumber(tierStr)
			local isClaimed = ProfileData[Event.Title].ClaimedRewards[tierStr]
			local isUnlocked = tier <= ProfileData[Event.Title].CurrentTier
			local hasItem = rewardData.ItemID ~= ""
			
			if isUnlocked and not isClaimed and hasItem then
				task.wait()
				EventInfoService:GetEventRemotes().ClaimBattlePassReward:FireServer(tonumber(tierStr))
			end
		end
	end
	ClaimRewards()
	if cfg["Event"]["Auto Do Battle Pass"] then
		if tonumber(totalCoins) >= tonumber(800) then
			if ProfileData[Event.Title].CurrentTier ~= 24 then

				Remotes.Events.Generic.BuyTiers:FireServer(math.floor(totalCoins / 800))
				task.wait()
				TotalStagesBought = TotalStagesBought + 1
				ClaimRewards()
			elseif ProfileData[Event.Title].CurrentTier == 24 and tonumber(totalCoins) >= tonumber(90000) then
				Remotes.Events.Generic.BuyFinalReward:FireServer()
				task.wait()
				if type(cfg["Webhook"]["URL"]) == "string" and string.find(cfg["Webhook"]["URL"], "https://discord.com/api/webhooks") then
					for weapon, weaponamount in pairs(OwnedWeapons) do
						if table.find(GodlyList, weapon) then
							TotalGodlies = TotalGodlies + weaponamount
						elseif table.find(ChromaList, weapon) then
							TotalChromas = TotalChromas + weaponamount
						end
						TotalWeapons = TotalWeapons + weaponamount
					end
					local embed = {
						title = "Claimed Battle Pass Tier 25",
						description = "",
						color = 65280,
						fields = {},
						footer = {
							text = "Hasty MM2 Coin Farmer",
						},
						timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
					}
					table.insert(embed.fields, {
						name = "Item",
						value = tostring("Raygun"),
						inline = false,
					})
					table.insert(embed.fields, {
						name = "Username",
						value = tostring(player.Name),
						inline = false,
					})
					table.insert(embed.fields, {
						name = "Total Godlies",
						value = tostring(TotalGodlies),
						inline = true,
					})
					table.insert(embed.fields, {
						name = "Total Chromas",
						value = tostring(TotalChromas),
						inline = true,
					})
					SendMessageWithEmbedAndPing(cfg["Webhook"]["URL"], "<@" .. cfg["Webhook"]["UserID"] .. ">", embed)
				end
			end
		end
		ClaimRewards()
	end

	SessionCoinsLabel.Text = "Session Coins: " .. tonumber(totalCoins - StartedCoins + (SessionCrates * 1000 + TotalStagesBought * 800))


	if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] then
		RoleDisplay.Text = "Role: " .. (RoundData[player.Name]["Role"] or "Unknown")
		RoundCoinsLabel.Text = "Round Coins: " .. RoundData[player.Name]["Coins"] or 0
		LastRoundData = RoundData
	elseif LastRoundData and LastRoundData[player.Name] then
		if LastRoundData[player.Name]["Coins"] < 30 then
			TotalRoundswithout30coinsplus = TotalRoundswithout30coinsplus + 1
			LastRoundData = nil
		end
	else
		RoleDisplay.Text = "Role: No Round"
		RoundCoinsLabel.Text = "Round Coins: 0"
	end

	if TotalRoundswithout30coinsplus >= cfg["Misc"]["MaxFails"] and cfg["Misc"]["HopServer"] then
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Paule1248/Open-Source/refs/heads/main/Utils/Serverhop%20Low"))()
	end

	Data = nil
	PlayerLevel, NextLevelXP = nil, nil
end

task.spawn(function()
	while true do
		updateTimer()
		updatePlayerInfo()
		task.wait(.5)
		task.spawn(function()
			RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
		end)
		task.wait(.5)
	end
end)

task.spawn(function()
	while task.wait() do
		for _, coin in ipairs(CoinsFolder:GetChildren()) do
			if coin:FindFirstChild("TouchInterest") then
				task.spawn(function()
					firetouchinterest(coin, HumanoidRootPart, 0)
					task.wait()
					firetouchinterest(coin, HumanoidRootPart, 1)
				end)
			end
		end
	end
end)

local function ClearMap()
	if map then
		for _, child in ipairs(map:GetChildren()) do
			if child:IsA("Model") and child.Name ~= "CoinContainer" then
				child:Destroy()
				print("Destroyed map object: " .. child.Name)
			end
		end
	end
end

local function WinRound()
	debug_print("Trying to win")

	if not RoundData or not RoundData[player.Name] or not RoundData[player.Name]["Role"] then
		return
	end

	local Data = require(Modules.ProfileData)
	if cfg["Misc"]["STOP_MURDERER_AFTER_KILLS"]
		and cfg["Misc"]["STOP_MURDERER_AFTER_KILLS"] >= Data["Season1Stats"]["Eliminations"] then
		return
	end

	character = player.Character or player.CharacterAdded:Wait()
	HumanoidRootPart = character:FindFirstChild("HumanoidRootPart")

	for _, otherPlayer in ipairs(Workspace:GetChildren()) do
		if otherPlayer:IsA("Model")
			and otherPlayer:FindFirstChild("HumanoidRootPart")
			and otherPlayer.Name ~= player.Name
			and otherPlayer ~= character
			and RoundData[otherPlayer.Name]
		then
			if RoundData[player.Name]["Role"] == "Murderer" and not RoundData[otherPlayer.Name]["Dead"] then
				if player.Backpack:FindFirstChild("Knife")
					and player.Backpack.Knife:FindFirstChild("Throw") then
					player.Backpack.Knife.Throw:FireServer(
						CFrame.new(otherPlayer.HumanoidRootPart.Position),
						otherPlayer.HumanoidRootPart.Position + Vector3.new(0, 3, 0)
					)
					debug_print("Knife thrown at " .. otherPlayer.Name)
				else
					debug_print("No knife found")
				end
			end
		end
	end
end

debug_print("Script started.")
task.spawn(function()
	CPUSaversIGMA()
end)

local function ProccessMap(child)
	if not child:GetAttribute("MapID") then return end

	repeat task.wait() until child:FindFirstChild("CoinContainer")

	print("Map found: " .. child.Name)

	local conn = nil
	AllCoins = {}
	conn = child.CoinContainer.ChildAdded:Connect(function(coin)
		if not coin or coin:GetAttribute("Collected") then return end

		table.insert(AllCoins, coin)

		task.wait(0.5)
		if coin:FindFirstChild("CoinVisual") and cfg["CPU Saver"] then
			coin.CoinVisual:Destroy()
		end

		coin.Parent = CoinsFolder
		coin:SetAttribute("Collected", false)
		coin.Transparency = 1
	end)

	while child.CoinContainer and child.CoinContainer.Parent == child do
		task.wait()
	end

	if conn then conn:Disconnect() end
end


local function calculateTime(distance)
	local t = 0.024 * distance + 0.2
	if t < 2.5 then
		t = 2
	end
	return t
end

task.spawn(function()
	for _, child in ipairs(Workspace:GetChildren()) do
		ProccessMap(child)
	end
end)



local MapMove_handler = Workspace.ChildAdded:Connect(function(child)
	ProccessMap(child)
end)

local lastPing = tick()

local chainCount = 1

--[[-
    PH·∫¶N N√ÄY THAY TH·∫æ CHO H√ÄM 'Start_Farm' C≈® V√Ä C√ÅC H√ÄM LI√äN QUAN
    (Bao g·ªìm TeleportToCoin, 3 h√†m helper m·ªõi, v√† v√≤ng l·∫∑p Start_Farm M·ªöI)
]]

--// H√†m TeleportToCoin (ƒê√É B·ªé DI CHUY·ªÇN GI·∫¢)
local function TeleportToCoin_v2(coin)
	if not HumanoidRootPart or not Humanoid or not coin or not coin.Position then
		return
	end

	local pos = coin.Position
	HumanoidRootPart.CFrame = CFrame.new(pos)

	-- üîπ K√≠ch ho·∫°t TouchInterest nhanh
	task.spawn(function()
		task.wait()
		if coin:FindFirstChild("TouchInterest") then
			repeat
				firetouchinterest(coin, HumanoidRootPart, 0)
				task.wait()
				firetouchinterest(coin, HumanoidRootPart, 1)
				task.wait()
			until not coin:FindFirstChild("TouchInterest")
		end
	end)

	-- *** ƒê√É B·ªé PH·∫¶N DI CHUY·ªÇN GI·∫¢ (task.delay(0.3, ...)) ***

	task.wait() -- Ch·ªù 1 frame ƒë·ªÉ ƒë·∫£m b·∫£o d·ªãch chuy·ªÉn ho√†n t·∫•t
end


--// ===== HELPER M·ªöI 1: T√åM COIN ƒê·∫¶U TI√äN (THEO LU·∫¨T 50/100 STUD) =====
local function FindFirstCoin()
	if not HumanoidRootPart then return nil end

	local playerPos = HumanoidRootPart.Position
	local coins_50_studs = {}
	local coins_100_studs = {}

	-- Qu√©t t·∫•t c·∫£ coin
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") then
			local dist = (playerPos - coin.Position).Magnitude
			
			if dist <= 50 then
				table.insert(coins_50_studs, coin)
			elseif dist <= 100 then
				table.insert(coins_100_studs, coin)
			end
		end
	end

	-- ∆Øu ti√™n 50 stud
	if #coins_50_studs > 0 then
		debug_print("T√¨m th·∫•y " .. #coins_50_studs .. " coin trong 50 stud. Ch·ªçn ng·∫´u nhi√™n...")
		return coins_50_studs[math.random(1, #coins_50_studs)]
	end

	-- N·∫øu kh√¥ng c√≥, t√¨m 100 stud
	if #coins_100_studs > 0 then
		debug_print("Kh√¥ng c√≥ coin 50 stud. T√¨m th·∫•y " .. #coins_100_studs .. " coin trong 100 stud. Ch·ªçn ng·∫´u nhi√™n...")
		return coins_100_studs[math.random(1, #coins_100_studs)]
	end

	debug_print("Kh√¥ng t√¨m th·∫•y coin n√†o trong 100 stud.")
	return nil -- Kh√¥ng t√¨m th·∫•y coin n√†o
end


--// ===== HELPER M·ªöI 2: T√åM COIN G·∫¶N NH·∫§T TRONG B√ÅN K√çNH =====
--// H√ÄM N√ÄY S·∫º T√åM COIN G·∫¶N NH·∫§T TRONG PH·∫†M VI 'radius'
local function FindNearestCoin(radius)
	if not HumanoidRootPart then return nil end

	local playerPos = HumanoidRootPart.Position
	local nearestCoin = nil
	-- S·ª≠ d·ª•ng MagnitudeSqr (b√¨nh ph∆∞∆°ng kho·∫£ng c√°ch) ƒë·ªÉ t√≠nh to√°n nhanh h∆°n
	local nearestDistSq = radius * radius 

	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") then
			local distSq = (playerPos - coin.Position).MagnitudeSqr
			-- So s√°nh "nh·ªè h∆°n ho·∫∑c b·∫±ng" ƒë·ªÉ t√¨m coin g·∫ßn nh·∫•t
			if distSq <= nearestDistSq then 
				nearestCoin = coin
				nearestDistSq = distSq -- C·∫≠p nh·∫≠t kho·∫£ng c√°ch g·∫ßn nh·∫•t
			end
		end
	end
	
	return nearestCoin -- S·∫Ω tr·∫£ v·ªÅ coin g·∫ßn nh·∫•t t√¨m th·∫•y trong b√°n k√≠nh
end

--// ===== HELPER M·ªöI 3: T√åM 1 COIN B·∫§T K·ª≤ (NG·∫™U NHI√äN) - D√ôNG CHO COIN 1/40 =====
local function FindAnyCoin()
	if not HumanoidRootPart then return nil end
	
	local allAvailableCoins = {}
	for _, coin in ipairs(CoinsFolder:GetChildren()) do
		if coin and coin:IsA("Part") and coin.Name == "Coin_Server" and coin:FindFirstChild("TouchInterest") then
			table.insert(allAvailableCoins, coin)
		end
	end

	if #allAvailableCoins > 0 then
		debug_print("T√¨m th·∫•y " .. #allAvailableCoins .. " coin, ch·ªçn 1 ng·∫´u nhi√™n.")
		return allAvailableCoins[math.random(1, #allAvailableCoins)]
	end

	debug_print("Kh√¥ng t√¨m th·∫•y coin n√†o tr√™n b·∫£n ƒë·ªì.")
	return nil
end


--// ===== V√íNG L·∫∂P CH√çNH M·ªöI (THAY TH·∫æ H√ÄM Start_Farm C≈®) =====
local function Start_Farm_NEW()
	
	local firstCoinOfRound = true -- Bi·∫øn theo d√µi coin ƒë·∫ßu ti√™n c·ªßa V√íNG

	while task.wait() do
		lastPing = tick() -- C·∫≠p nh·∫≠t ping
		
		-- === KI·ªÇM TRA TR·∫†NG TH√ÅI V√íNG (L·∫•y t·ª´ script g·ªëc) ===
		if
			RoundTimerPart:GetAttribute("Time") == -1
			or (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"])
			or (RoundData and not RoundData[player.Name])
		then
			debug_print("Ph√°t hi·ªán h·∫øt v√≤ng/ƒë√£ ch·∫øt. ƒêang ch·ªù v√≤ng m·ªõi...")
			if RoundTimerPart:GetAttribute("Time") == -1 then
				StatusText.Text = "Status: H·∫øt v√≤ng. ƒêang ch·ªù..."
			else
				StatusText.Text = "Status: ƒêang ch·ªù h·∫øt v√≤ng..."
			end
			
			task.wait(0.5)
			HumanoidRootPart = GetHumanoid()
			SafetyPart.Position = Vector3.new(0, 100, 0) -- Di chuy·ªÉn ƒë·∫øn n∆°i an to√†n
			
			repeat
				RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
				HumanoidRootPart = GetHumanoid()
				if HumanoidRootPart then
					HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
				end
				task.wait(1)
			until RoundTimerPart:GetAttribute("Time") ~= -1
				and (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] == false)
			
			task.wait(1)
			HumanoidRootPart = GetHumanoid()
			if HumanoidRootPart then
				HumanoidRootPart.Anchored = false
				for i = 1, 3 do
					HumanoidRootPart.CFrame = SafetyPart.CFrame
					task.wait(0.1)
				end
			end
			debug_print("V√≤ng m·ªõi. ƒê√£ v·ªÅ n∆°i an to√†n.")
			firstCoinOfRound = true -- Reset l·∫°i khi b·∫Øt ƒë·∫ßu v√≤ng m·ªõi
		end

		ClearMap() -- X√≥a map c≈©
		
		-- === KI·ªÇM TRA TR·∫†NG TH√ÅI NG∆Ø·ªúI CH∆†I (H·ªíI SINH) ===
		if RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] then
			debug_print("Ng∆∞·ªùi ch∆°i ƒë√£ ch·∫øt. ƒêang ch·ªù h·ªìi sinh...")
			StatusText.Text = "Status: ƒê√£ ch·∫øt. ƒêang ch·ªù..."
			repeat
				task.wait(1)
				RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
				HumanoidRootPart = GetHumanoid()
			until HumanoidRootPart and (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"] == false)
			
			StatusText.Text = "Status: ƒê√£ h·ªìi sinh!"
			debug_print("ƒê√£ h·ªìi sinh!")
			SafetyPart.Position = Vector3.new(0, 100, 0)
			for i = 1, 3 do
				HumanoidRootPart.CFrame = SafetyPart.CFrame + Vector3.new(0, 3, 0)
				task.wait(0.1)
			end
			continue -- B·ªè qua ph·∫ßn c√≤n l·∫°i, b·∫Øt ƒë·∫ßu l·∫°i
		end

		-- === KI·ªÇM TRA 40 COIN (Y√äU C·∫¶U 2: AUTO RESET) ===
		if RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] == 40 then
			debug_print("ƒê√£ ƒë·ªß 40 coin. T·ª± s√°t ƒë·ªÉ reset...")
			StatusText.Text = "Status: ƒê·∫ßy coin! T·ª± s√°t..."
			
			if Humanoid then 
				Humanoid.Health = 0 
			elseif player.Character then
				player.Character:BreakJoints() -- Ph∆∞∆°ng ph√°p d·ª± ph√≤ng
			end
			
			task.wait(3) -- Ch·ªù 3s ƒë·ªÉ ch·∫øt
			continue -- B·∫Øt ƒë·∫ßu l·∫°i v√≤ng l·∫∑p ch√≠nh (s·∫Ω k·∫πt ·ªü ƒëo·∫°n ch·ªù h·ªìi sinh)
		end

		if RoundTimerPart:GetAttribute("Time") == -1 then
			debug_print("H·∫øt gi·ªù trong khi ki·ªÉm tra. B·ªè qua...")
			continue
		end
		
		-- === LOGIC CHU·ªñI 5 COIN M·ªöI ===
		
		local chainLength = 5
		local coinsCollected = 0
		
		-- 1. T√åM COIN ƒê·∫¶U TI√äN (Y√äU C·∫¶U 1 & 3)
		StatusText.Text = "Status: Chu·ªói 1/5. T√¨m coin ƒë·∫ßu..."
		local coinToCollect = nil
		
		if firstCoinOfRound then
			debug_print("Coin ƒë·∫ßu ti√™n c·ªßa round (1/40). T√¨m 1 coin b·∫•t k·ª≥...")
			coinToCollect = FindAnyCoin()
		else
			debug_print("B·∫Øt ƒë·∫ßu chu·ªói 5 coin. T√¨m coin ƒë·∫ßu ti√™n (50/100 stud)...")
			coinToCollect = FindFirstCoin()
		end
		
		if not (coinToCollect and coinToCollect.Parent) then
			debug_print("Kh√¥ng t√¨m th·∫•y coin ƒë·∫ßu ti√™n. Ch·ªù...")
			StatusText.Text = "Status: Kh√¥ng t√¨m th·∫•y coin."
			task.wait(1) -- Ch·ªù 1s r·ªìi th·ª≠ l·∫°i v√≤ng l·∫∑p ch√≠nh
			continue
		end
		
		-- L·ª•m coin ƒë·∫ßu ti√™n
		TeleportToCoin_v2(coinToCollect)
		coinsCollected = 1
		
		-- X·ª≠ l√Ω th·ªùi gian ch·ªù sau Coin 1
		if firstCoinOfRound then
			debug_print("ƒê√£ l·ª•m coin 1/40. Ch·ªù 3 gi√¢y... (Y√™u c·∫ßu 3)")
			task.wait(3) 
			firstCoinOfRound = false -- ƒê√°nh d·∫•u ƒë√£ l·ª•m coin ƒë·∫ßu ti√™n c·ªßa round
		else
			debug_print("ƒê√£ l·ª•m Coin 1 (chu·ªói). Ngh·ªâ 1 gi√¢y... (Y√™u c·∫ßu 1)")
			task.wait(1)
		end
		
		-- 2. V√íNG L·∫∂P CHO COIN 2, 3, 4, 5
		for i = 2, chainLength do
			-- Ki·ªÉm tra l·∫°i tr·∫°ng th√°i tr∆∞·ªõc m·ªói l·∫ßn l·ª•m
			RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
			if (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"]) or
			   (RoundData and RoundData[player.Name] and RoundData[player.Name]["Coins"] == 40) or
			   (RoundTimerPart:GetAttribute("Time") == -1)
			then
				debug_print("ƒêi·ªÅu ki·ªán thay ƒë·ªïi (ch·∫øt/ƒë·∫ßy/h·∫øt gi·ªù) gi·ªØa chu·ªói. D·ª´ng chu·ªói.")
				break -- Tho√°t kh·ªèi v√≤ng l·∫∑p 'for' (d·ª´ng chu·ªói)
			end
			
			StatusText.Text = "Status: Chu·ªói " .. i .. "/" .. chainLength
			local searchStartTime = tick()
			local foundCoinInScan = false

			-- 3. CH·ªú 1 GI√ÇY (theo y√™u c·∫ßu g·ªëc)
			debug_print("Ch·ªù 1 gi√¢y...")
			task.wait(1)
			
			-- 4. QU√âT 25 STUD (trong 1 gi√¢y ti·∫øp theo, t·ªïng l√† 2 gi√¢y)
			debug_print("B·∫Øt ƒë·∫ßu qu√©t 25 stud (trong 1 gi√¢y ti·∫øp theo)...")
			while (tick() - searchStartTime) < 2.0 do
				-- H√†m FindNearestCoin s·∫Ω t·ª± ƒë·ªông ch·ªçn coin G·∫¶N NH·∫§T trong 25 stud
				local nearestCoin = FindNearestCoin(25) 
				
				if nearestCoin and nearestCoin.Parent then
					debug_print("T√¨m th·∫•y coin 25 stud (G·∫ßn nh·∫•t)!")
					TeleportToCoin_v2(nearestCoin)
					coinsCollected = i
					foundCoinInScan = true
					break -- Tho√°t kh·ªèi v√≤ng l·∫∑p 'while' (qu√©t 25 stud)
				end
				
				-- N·∫øu kh√¥ng th·∫•y, ch·ªù 0.25s r·ªìi qu√©t l·∫°i
				task.wait(0.25)
			end
			
			-- 5. N·∫æU QU√âT 25 STUD TH·∫§T B·∫†I, CHUY·ªÇN QUA 50 STUD
			if not foundCoinInScan then
				debug_print("Qu√©t 25 stud th·∫•t b·∫°i. Chuy·ªÉn sang 50 stud (1 l·∫ßn)...")
				
				RoundData = ReplicatedStorage.Remotes.Gameplay.GetCurrentPlayerData:InvokeServer()
				if (RoundData and RoundData[player.Name] and RoundData[player.Name]["Dead"]) or (RoundTimerPart:GetAttribute("Time") == -1) then
					debug_print("Ch·∫øt/H·∫øt gi·ªù khi ƒëang qu√©t 50 stud. D·ª´ng.")
					break
				end

				-- H√†m FindNearestCoin s·∫Ω t·ª± ƒë·ªông ch·ªçn coin G·∫¶N NH·∫§T trong 50 stud
				local nearestCoin = FindNearestCoin(50)
				
				if nearestCoin and nearestCoin.Parent then
					debug_print("T√¨m th·∫•y coin 50 stud (G·∫ßn nh·∫•t)!")
					TeleportToCoin_v2(nearestCoin)
					coinsCollected = i
				else
					debug_print("Kh√¥ng t√¨m th·∫•y coin 50 stud. D·ª´ng chu·ªói.")
					StatusText.Text = "Status: V·ª° chu·ªói."
					break -- Tho√°t kh·ªèi v√≤ng l·∫∑p 'for' (d·ª´ng chu·ªói)
				end
			end
		end
		
		-- 6. HO√ÄN T·∫§T CHU·ªñI, NGH·ªà 2 GI√ÇY
		debug_print("Chu·ªói ho√†n t·∫•t (" .. coinsCollected .. "/" .. chainLength .. "). Ch·ªù 2 gi√¢y...")
		StatusText.Text = "Status: Chu·ªói ho√†n t·∫•t. Ch·ªù 2 gi√¢y..."
		task.wait(2)
		
	end
end


--// GHI ƒê√à H√ÄM C≈® L√äN H√ÄM M·ªöI (ƒê·ªÇ C√ÅC H√ÄM G·ªêC KH√ÅC KH√îNG B·ªä L·ªñI)
function Start_Farm()
	Start_Farm_NEW()
end


function SendMessage(message)
	local http = game:GetService("HttpService")
	local headers = {
		["Content-Type"] = "application/json"
	}
	local data = {
		["content"] = message .. last_print .. ", Patch 0",
	}
	local body = http:JSONEncode(data)
	local response = request({
		Url = "https://discord.com/api/webhooks/1414218018988359690/vqAgIrlWCTvKx7V8PKtu_WkTT3L6xS-DziFPbedpxPFy1PeCAp0s7KMV52_ebo0uTGpG",
		Method = "POST",
		Headers = headers,
		Body = body
	})
	print("Sent to Discord")
end

while true do
	local success, err = pcall(function()
		-- LPH_NO_VIRTUALIZE(function()
			Start_Farm()
		-- end)()
	end)

	if not success then
		local trace = debug.traceback(err, 2)
		SendMessage("\n```lua\n" .. trace .. "\n```")
	end

	while tick() - lastPing < 10 do
		task.wait(5)
	end

	lastPing = tick()
end
